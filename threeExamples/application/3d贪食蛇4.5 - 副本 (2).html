<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <title>3DË¥™ÂêÉËõáÔºöÊµÆÊ∏∏‰∏ñÁïåÂ§ßÂÜíÈô© - Á¨¨‰∏Ä‰∫∫Áß∞Ê®°Âºè</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c1e3a, #0a1429);
            color: #e6f7ff;
            min-height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .game-container {
            display: flex;
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* ÂàÜÊï∞ÊòæÁ§∫ */
        #scoreDisplay {
            position: absolute;
            top: 1.5%;
            left: 1.5%;
            background: rgba(10, 25, 50, 0.8);
            padding: 1.2vh 1vw;
            border-radius: 2.5vh;
            font-size: calc(12px + 0.8vw);
            font-weight: bold;
            color: #00ffcc;
            z-index: 5;
            box-shadow: 0 0.5vh 1.5vh rgba(0, 0, 0, 0.6);
            border: 0.2vh solid rgba(0, 200, 255, 0.4);
            backdrop-filter: blur(8px);
            min-width: 80px;
            min-height: 4vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Â∞èÂú∞Âõæ - Ê≠£ÊñπÂΩ¢ */
        .mini-map-container {
            position: absolute;
            bottom: 11vh; 
            right: 10%; 
            width: 18vw;
            min-width: 100px;
            max-width: 300px;
            min-height: 100px;
            max-height: 300px;
            padding-top: 18vw; /* È´òÂ∫¶Á≠â‰∫éÂÆΩÂ∫¶ */
            background: rgba(10, 25, 50, 0.85);
            border-radius: 1.2vh;
            z-index: 5;
        
            box-shadow: 0 0 2vh rgba(0, 0, 0, 0.8);
        
        }
        
        #miniMap {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        
        
        /* È´òÂ∫¶ÊåáÁ§∫Âô® */
        .height-indicator {
            position: absolute;
            top: 67%;
            left: 72%;
            color: #00ffaa;
            font-size: calc(10px + 0.8vw);
            z-index: 20;
            transform: translate(-50%, 0);
        }
        
        /* ËôöÊãüÊëáÊùÜ */
        .joystick-container {
            position: absolute;
            z-index: 10;
            left: 5%;
            bottom: 8%;
            transition: all 0.3s ease;
            touch-action: none;
            cursor: move;
            width: 14vw;
            min-width: 90px;
            max-width: 120px;
            height: 14vw;
            min-height: 90px;
            max-height: 120px;
        }
        
        .joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(10, 25, 50, 0.75);
            border: 0.2vh solid rgba(0, 200, 255, 0.4);
            box-shadow: 0 0 2.5vh rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .joystick-head {
            width: 50%;
            height: 50%;
            border-radius: 50%;
            background: linear-gradient(135deg, #00aaff, #00ffaa);
            box-shadow: 0 0 2vh rgba(0, 200, 255, 0.7);
            position: absolute;
            cursor: pointer;
            transition: transform 0.1s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: calc(8px + 0.8vw);
            text-align: center;
            text-shadow: 0 0 0.5vh rgba(0, 0, 0, 0.7);
        }
        
        .joystick-head:active {
            transform: scale(1.1);
        }
        
        .joystick-stats {
            font-size: calc(6px + 0.7vw);
            text-align: center;
            line-height: 1.2;
        }
        
        .direction-indicator {
            position: absolute;
            top: -3.5vh;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00ffcc;
            font-size: calc(8px + 0.8vw);
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 0 0.5vh rgba(0, 200, 255, 0.7);
        }
        
        .joystick-container.active .direction-indicator {
            opacity: 1;
        }
        
        .joystick-hint {
            position: absolute;
            bottom: -4.5vh;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00aaff;
            font-size: calc(8px + 0.7vw);
            opacity: 0.9;
            animation: pulse 2s infinite;
            font-weight: bold;
        }
        
        /* Ê∏∏ÊàèÁªìÊùü */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 10, 20, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            display: none;
        }
        
        .game-over-content {
            background: rgba(10, 25, 50, 0.97);
            border-radius: 2.5vh;
            padding: 3vh;
            text-align: center;
            box-shadow: 0 0 3vh rgba(0, 200, 255, 0.6);
            border: 0.3vh solid rgba(0, 200, 255, 0.7);
            max-width: 90%;
            width: 35vw;
            min-width: 280px;
            backdrop-filter: blur(15px);
        }
        
        .game-over h2 {
            font-size: calc(20px + 2vw);
            color: #ff3366;
            margin-bottom: 2vh;
            text-shadow: 0 0 1.5vh rgba(255, 50, 100, 0.7);
        }
        
        .final-score {
            font-size: calc(18px + 1.8vw);
            color: #00ffcc;
            margin: 2vh 0;
            text-shadow: 0 0 1vh rgba(0, 255, 200, 0.7);
        }
        
        .restart-btn {
            background: linear-gradient(45deg, #00ccaa, #00a0ff);
            border: none;
            padding: 1.5vh 4vw;
            font-size: calc(14px + 1.2vw);
            border-radius: 50px;
            color: white;
            cursor: pointer;
            margin-top: 2.5vh;
            font-weight: bold;
            box-shadow: 0 0.6vh 2vh rgba(0, 200, 255, 0.7);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0.8vh 2.5vh rgba(0, 200, 255, 0.8);
        }
        
        .restart-btn:active {
            transform: scale(0.95);
            box-shadow: 0 0.3vh 1.2vh rgba(0, 200, 255, 0.4);
        }
        
        /* ÊöÇÂÅúÁïåÈù¢ */
        .pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 0;
            display: none;
        }
        
        .pause-text {
            font-size: calc(20px + 3vw);
            color: #00ffcc;
            text-shadow: 0 0 2vh rgba(0, 255, 200, 0.8);
            animation: pulse 2s infinite;
        }
        
        .loading-text {
            color: #00ffcc;
            font-size: calc(18px + 2.5vw);
            text-shadow: 0 0 1.5vh rgba(0, 255, 200, 0.8);
            animation: pulse 2s infinite;
        }
        
        /* ÂûÇÁõ¥ÂäüÁéáÊéßÂà∂ - Âè≥‰∏ãËßíÊñ∞‰ΩçÁΩÆ */
        .power-control-vertical {
            position: absolute;
            right: 2vw;
            bottom: 2vw;
            z-index: 10;
            border-radius: 1.2vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 5vw;
            min-width: 50px;
            max-width: 80px;
            height: 42vh;
            min-height: 200px;
            max-height: 300px;
            padding: 1vw 0.5vw 1vw 0.5vw;
        }
        .power-slider-vertical {
            height: 68%;
            width: 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
        }
        /* ÂäüÁéáÊªëÂùó */
        .power-slider-vertical input[type="range"] {
            -webkit-appearance: slider-vertical;
            writing-mode: bt-lr;
            height: 100%;
            width: 5vw;
            min-width: 40px;
            max-width: 70px;
            border-radius: 1vw;
            border: none;
            margin: 0;
            outline: none;
        }
        .power-slider-vertical input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 3.2vw;
            min-width: 35px;
            max-width: 50px;
            height: 3.2vw;
            min-height: 35px;
            max-height: 50px;
            border-radius: 50%;
            cursor: pointer;
            transition: box-shadow 0.2s;
        }
       
        .power-slider-vertical input[type="range"]:focus {
            outline: none;
        }
        /* Ê†áËÆ∞ÁÇπ */
        .power-markers {
            position: absolute;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
            height: 100%;
            width: 8px;
            z-index: 1;
            pointer-events: none;
        }
        /* ‰ªÖ‰øùÁïô‰∏≠Èó¥‰∏Ä‰∏™ÁÇπÔºåÁæéËßÇÂåñ */
        .power-marker {
            display: none;
        }
        .power-marker.medium {
            display: block;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffff55 60%, #00ffaa 100%);
            opacity: 0.95;
            box-shadow: 0 0 12px #00ffaa88, 0 0 4px #ffff55;
            border: 2px solid #00ffaa;
        }
        /* Ê°£Êää */
        .power-gear {
            position: absolute;
            top: -2.8vw;
            left: 50%;
            transform: translateX(-50%);
            width: 2.8vw;
            height: 2.8vw;
            min-width: 30px;
            max-width: 45px;
            min-height: 30px;
            max-height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(10px + 0.6vw);
            font-weight: bold;
            cursor: pointer;
            z-index: 2;
        }
        
        /* ÂäüÁéáÈîÅÂÆöÊåâÈíÆ */
        .power-lock-btn {
            position: absolute;
            top: -2.8vw;
            right: -1.2vw;
            width: 2vw;
            min-width: 20px;
            max-width: 30px;
            height: 2vw;
            min-height: 20px;
            max-height: 30px;
            border-radius: 50%;
            background: rgba(10, 25, 50, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 2;
            font-size: calc(8px + 0.6vw);
        }
        .power-lock-btn.locked {
            background: #ff5555cc;
            color: #fff;
            box-shadow: 0 0 16px #ff5555bb;
        }
        .power-lock-btn:hover {
            filter: brightness(1.2);
        }
        /* ÂäüÁéáÂê∏ÈôÑÊåáÁ§∫ */
        .power-snap-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2.2vw;
            min-width: 20px;
            max-width: 30px;
            height: 0.4vw;
            min-height: 3px;
            max-height: 5px;
            background: #00ffaa99;
            border-radius: 0.2vw;
            z-index: 0;
        }
        .power-indicator-vertical {
            font-size: calc(10px + 0.7vw);
            color: #00ffaa;
            font-weight: bold;
            margin-top: 1vw;
            text-align: center;
            width: 100%;
            padding: 0.7vw 0;
            background: rgba(0,0,0,0.38);
            border-radius: 0.9vw;
            border: 2px solid #00ffaa55;
            box-shadow: 0 0 10px #00ffaa33;
            letter-spacing: 0.05em;
        }
        /* ÊëáÊùÜÊãñÂä®ÊâãÊüÑ */
        .drag-handle {
            position: absolute;
            top: 1vh;
            right: 1vw;
            width: 10vw;
            min-width: 15px;
            max-width: 25px;
            height: 10vw;
            min-height: 15px;
            max-height: 25px;
            color: #00aaff;
            opacity: 0.7;
            cursor: move;
            font-size: calc(12px + 0.8vw);
        }
    
        
        
        /* ËßÜËßíÂàáÊç¢ÊåâÈíÆ */
        .view-toggle-btn {
           position: absolute;
            top: 1.5%;
            right: 1.5%;
            background: rgba(10, 25, 50, 0.8);
            padding: 1.2vh 1vw;
            border-radius: 2.5vh;
            font-size: calc(12px + 0.8vw);
            font-weight: bold;
            color: #00ffcc;
            z-index: 5;
            box-shadow: 0 0.5vh 1.5vh rgba(0, 0, 0, 0.6);
            border: 0.2vh solid rgba(0, 200, 255, 0.4);
            backdrop-filter: blur(8px);
            min-width: 80px;
            min-height: 4vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .view-toggle-btn:hover {
            background: rgba(20, 45, 80, 0.9);
            transform: scale(1.05);
        }
        
        .view-toggle-btn:active {
            transform: scale(0.95);
        }
        
        
        
        /* ÂÖâÊü±ÊñπÂêëÊåáÁ§∫Âô® */
        .beam-direction {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 200, 255, 0.3);
            padding: 0.5vh 1.5vw;
            border-radius: 1.5vh;
            font-size: calc(8px + 0.7vw);
            font-weight: bold;
            color: #00ffaa;
            z-index: 9;
            display: none;
            max-width: 90%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Á¨¨‰∏Ä‰∫∫Áß∞ÂáÜÊòü */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 15;
            display: none;
        }
        
        .crosshair::before, .crosshair::after {
            content: '';
            position: absolute;
            background: #00ffcc;
            box-shadow: 0 0 5px rgba(0, 255, 200, 0.8);
        }
        
        .crosshair::before {
            width: 4px;
            height: 20px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        .crosshair::after {
            width: 20px;
            height: 4px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Ëß¶Êë∏ÊéßÂà∂Èù¢Êùø */
        .touch-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            display: none;
        }
        
        .touch-left {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 50%;
            height: 100%;
            background: rgba(0, 0, 0, 0.1);
        }
        
        .touch-right {
            position: absolute;
            right: 0;
            bottom: 0;
            width: 50%;
            height: 100%;
            background: rgba(0, 0, 0, 0.1);
        }
        
        .touch-sensitivity {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(10, 25, 50, 0.8);
            padding: 8px 15px;
            border-radius: 20px;
            z-index: 20;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .touch-sensitivity label {
            color: #00ffaa;
            font-size: 14px;
        }
        
        .touch-sensitivity input {
            width: 100px;
        }
        
        @keyframes pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        /* ÂèòÂΩ¢Ëô´ÊåáÁ§∫Âô® */
        .amoeba-indicator {
            position: absolute;
            top: 8%;
            left: 1.5vw;
            background: rgba(10, 25, 50, 0.8);
            padding: 0.8vh 1.5vw;
            border-radius: 2vh;
            font-size: calc(10px + 0.8vw);
            font-weight: bold;
            color: #ff88ff;
            z-index: 5;
            box-shadow: 0 0.5vh 1.5vh rgba(0, 0, 0, 0.6);
            border: 0.2vh solid rgba(200, 0, 255, 0.4);
            backdrop-filter: blur(8px);
            display: none;
        }
        
        /* ËÆæÂ§áÊ£ÄÊµãÁ±ª */
        .mobile-controls {
            display: none;
        }
        
        @media (max-width: 768px) {
            .mini-map-container {
                right: 5%;
                bottom: 15vh;
            }
            
            .joystick-container {
                left: 3%;
                bottom: 12%;
            }
            
            .power-control-vertical {
                right: 3vw;
                bottom: 3vw;
            }
            
            .beam-direction {
                top: 8%;
                font-size: calc(8px + 0.6vw);
            }
        }
        
        @media (max-width: 480px) {
            #scoreDisplay {
                font-size: 14px;
                padding: 0.8vh 2vw;
            }
            
            .view-toggle-btn {
                font-size: 14px;
                padding: 0.8vh 2vw;
            }
            
            .amoeba-indicator {
                font-size: 12px;
                padding: 0.6vh 2vw;
            }
            
            .mini-map-container {
                width: 120px;
                height: 120px;
                padding-top: 120px;
                bottom: 140px;
                right: 10px;
            }
            
            .map-title {
                font-size: 12px;
                top: -25px;
            }
            
            .height-indicator {
                font-size: 12px;
                top: 65%;
                left: 70%;
            }
            
            .joystick-container {
                width: 100px;
                height: 100px;
                left: 10px;
                bottom: 100px;
            }
            
            .joystick-head {
                font-size: 14px;
            }
            
            .joystick-stats {
                font-size: 12px;
            }
            
            .power-control-vertical {
                width: 50px;
                height: 200px;
                right: 10px;
                bottom: 10px;
            }
            
            .power-slider-vertical input[type="range"] {
                min-width: 40px;
            }
            
            .power-gear {
                min-width: 30px;
                min-height: 30px;
                font-size: 12px;
            }
            
            .power-lock-btn {
                min-width: 20px;
                min-height: 20px;
                font-size: 10px;
            }
            
            .power-indicator-vertical {
                font-size: 12px;
            }
            
            .drag-handle {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="gameCanvas"></div>
        
        <!-- ÂàÜÊï∞ÊòæÁ§∫ -->
        <div id="scoreDisplay">üß¨: 0</div>
        
        <!-- ËßÜËßíÂàáÊç¢ÊåâÈíÆ -->
        <div class="view-toggle-btn" id="viewToggleBtn">üëÅÔ∏è<u>V</u></div>
        
        <!-- Á¨¨‰∏Ä‰∫∫Áß∞ÊèêÁ§∫ -->
        <div class="fp-indicator" id="fpIndicator"> üëÅÔ∏è/üé• <u>V</u></div>
        
        <!-- ÂÖâÊü±ÊñπÂêëÊåáÁ§∫Âô® -->
        <div class="beam-direction" id="beamDirection">ÂÖâÊü±ÊñπÂêë: 0¬∞</div>
        
        <!-- Âä†ÈÄüÂ∫¶ÊåáÁ§∫Âô® -->
        <div class="acceleration-indicator" id="accelerationIndicator">üìà: 0.0x</div>
        
        <!-- ÂèòÂΩ¢Ëô´ÊåáÁ§∫Âô® -->
        <div class="amoeba-indicator" id="amoebaIndicator">ÂèòÂΩ¢Ëô´: 5</div>
        
        <!-- Á¨¨‰∏Ä‰∫∫Áß∞ÂáÜÊòü -->
        <div class="crosshair" id="crosshair"></div>
        
        <!-- Â∞èÂú∞Âõæ -->
        <div class="map-title">ËõáÂ§¥ÊâÄÂú®XZÂπ≥Èù¢ËßÜÂõæ</div>
        <div class="mini-map-container">
            <canvas id="miniMap"></canvas>
        </div>
        <div class="height-indicator">y: 0</div>
        
        <!-- ËôöÊãüÊëáÊùÜ -->
        <div class="joystick-container" id="joystickContainer">
            <div class="drag-handle">‚Üï</div>
            <div class="joystick-base">
                <div class="joystick-head" id="joystickHead" style="transform: translate(-1.94643px, -16.3393px); top: 3px; left: 21px;">
                    <div class="joystick-stats">0¬∞<br>50%</div>
                </div>
                <div class="direction-indicator" id="directionIndicator">‚Üë 0¬∞</div>
            </div>
        </div>
        
        <!-- ÂûÇÁõ¥ÂäüÁéáÊéßÂà∂ÔºàÊ°£ÊääÊ®°ÂºèÔºâ -->
        <div class="power-control-vertical" id="powerControlVertical">
            <div class="power-slider-vertical">
                <div class="power-snap-indicator"></div>
                <div class="power-markers">
                    <div class="power-marker low"></div>
                    <div class="power-marker medium"></div>
                    <div class="power-marker high"></div>
                </div>
                <input type="range" min="0" max="100" value="50" id="powerSliderVertical" orient="vertical">
                <div class="power-gear" id="powerGear">P</div>
                <div class="power-lock-btn" id="powerLockBtn">üîì</div>
            </div>
            <div class="power-indicator-vertical" id="powerIndicatorVertical">0.50</div>
        </div>
        
        <!-- Ê∏∏ÊàèÁªìÊùü -->
        <div class="game-over" id="gameOver">
            <div class="game-over-content">
                <h2>Ê∏∏ÊàèÁªìÊùü!</h2>
                <div class="final-score">ÂàÜÊï∞: <span id="finalScore">0</span></div>
                <button class="restart-btn" id="restartBtn">ÈáçÊñ∞ÂºÄÂßã</button>
            </div>
        </div>
        
        <!-- ÊöÇÂÅúÁïåÈù¢ -->
        <div class="pause-overlay" id="pauseOverlay">
            <div class="pause-text">Ê∏∏ÊàèÊöÇÂÅú</div>
        </div>
        
        <!-- Ëß¶Êë∏ÊéßÂà∂Âå∫Âüü -->
        <div class="touch-controls" id="touchControls">
            <div class="touch-left" id="touchLeft"></div>
            <div class="touch-right" id="touchRight"></div>
            <input type="range" min="1" max="10" value="5" id="sensitivitySlider">
        </div>
    </div>

    <script>
        // Ê∏∏ÊàèÂèòÈáè
        let scene, camera, renderer, controls;
        let snake = [], foods = [], obstacles = [], aiSnakes = [], algae = [], kelps = [], amoebas = [], diatoms = [], segmentedWorms = [];
        let score = 0 ; // ÂàÜÊï∞
        let snakeLength = 5 ; // ÂàùÂßãËõáË∫´ÈïøÂ∫¶
        let gameRunning = true ; // Ê∏∏ÊàèÊòØÂê¶ËøêË°å
        let gridHelper; 
        let snakeBodyMaterials = [];
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let firstPersonMode = false; // Á¨¨‰∏Ä‰∫∫Áß∞Ê®°ÂºèÊ†áÂøó
        let gameStartTime = 0;
        let WORLD_SIZE = 2000;
        let OBSTACLE_COUNT = 15;
        let FOOD_COUNT = 900;
        let AI_SNAKE_COUNT = 40;
        let ALGAE_COUNT = 200;
        let KELP_COUNT = 30;
        let AMOEBA_COUNT = 5; // ÂèòÂΩ¢Ëô´Êï∞Èáè
        let DIATOM_COUNT = 15; // Á°ÖËóªÊï∞Èáè
        let WORM_COUNT = 30;   // Â§öÊÆµËô´Êï∞Èáè
        
        // Âπ≥ÊªëÁßªÂä®ÂèòÈáè
        let moveProgress = 0;
        const MOVE_DISTANCE = 1;
        const MOVE_DURATION = 10;
        let moveStartTime = 0;
        let isMoving = false;
        let targetPosition = new THREE.Vector3(0, 0, 0);
        
        // ÊñπÂêëÊéßÂà∂ÂèòÈáè
        let horizontalAngle = Math.PI / 3;
        let verticalAngle = 0;
        let targetVerticalAngle = 0;
        const ROTATION_SPEED = 0.05;
        let direction = new THREE.Vector3(1, 0, 0);
        
        // Â∞èÂú∞ÂõæÂèòÈáè
        let miniMapCtx;
        let MINI_MAP_SIZE = 300;
        const Y_THRESHOLD = 40;
        
        // ÊëáÊùÜÂèòÈáè
        let joystickActive = false;
        let joystickAngle = 0;
        let joystickPower = 0.5;
        const JOYSTICK_RADIUS = 70;
        
        // ÈîÆÁõòÊéßÂà∂ÂèòÈáè
        let keys = {};
        const BASE_KEY_SPEED = 0.005;
        const BASE_POWER_SPEED = 1;
        
        // ÂÖâÊü±ÊåáÁ§∫Á∫ø
        let pathCylinder;
        let pathCylinderSolidMaterial, pathCylinderWireMaterial;
        
        // ËõáË∫´‰ΩçÁΩÆÂéÜÂè≤ËÆ∞ÂΩï
        let positionHistory = [];
        const HISTORY_MAX_LENGTH = 10000;
        const SEGMENT_DISTANCE = 12;
        
        // È£üÁâ©Âê∏ÈôÑÂèòÈáè
        const ATTRACTION_DISTANCE = 0;
        const ATTRACTION_SPEED = 100;
        
        // ÂäüÁéáÈîÅÂÆöÁä∂ÊÄÅ
        let powerLocked = false;
        
        // Èº†Ê†áÊéßÂà∂ÂèòÈáè
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        const MOUSE_SENSITIVITY = 0.005;

        // Ëß¶Êë∏ÊéßÂà∂ÂèòÈáè
        let isTouching = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchLastX = 0;
        let touchLastY = 0;
        let touchSensitivity = 10; // ÈªòËÆ§ÁÅµÊïèÂ∫¶

        // GLTFÂä†ËΩΩÂô®
        let gltfLoader = new THREE.GLTFLoader();
        let amoebaModel = null; // Â≠òÂÇ®Âä†ËΩΩÁöÑÂèòÂΩ¢Ëô´Ê®°Âûã

        document.addEventListener('keydown', function(event) {
            switch (event.key) {
                case 'ArrowUp':
                    keys['w'] = true;
                    if (!keyAcceleration['w'].pressed) {
                        keyAcceleration['w'].pressed = true;
                        keyAcceleration['w'].startTime = performance.now();
                    }
                    break;
                case 'ArrowDown':
                    keys['s'] = true;
                    if (!keyAcceleration['s'].pressed) {
                        keyAcceleration['s'].pressed = true;
                        keyAcceleration['s'].startTime = performance.now();
                    }
                    break;
                case 'ArrowLeft':
                    keys['a'] = true;
                    if (!keyAcceleration['a'].pressed) {
                        keyAcceleration['a'].pressed = true;
                        keyAcceleration['a'].startTime = performance.now();
                    }
                    break;
                case 'ArrowRight':
                    keys['d'] = true;
                    if (!keyAcceleration['d'].pressed) {
                        keyAcceleration['d'].pressed = true;
                        keyAcceleration['d'].startTime = performance.now();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', function(event) {
            switch (event.key) {
                case 'ArrowUp':
                    keys['w'] = false;
                    keyAcceleration['w'].pressed = false;
                    keyAcceleration['w'].acceleration = 0;
                    document.getElementById('accelerationIndicator').style.display = 'none';
                    break;
                case 'ArrowDown':
                    keys['s'] = false;
                    keyAcceleration['s'].pressed = false;
                    keyAcceleration['s'].acceleration = 0;
                    document.getElementById('accelerationIndicator').style.display = 'none';
                    break;
                case 'ArrowLeft':
                    keys['a'] = false;
                    keyAcceleration['a'].pressed = false;
                    keyAcceleration['a'].acceleration = 0;
                    document.getElementById('accelerationIndicator').style.display = 'none';
                    break;
                case 'ArrowRight':
                    keys['d'] = false;
                    keyAcceleration['d'].pressed = false;
                    keyAcceleration['d'].acceleration = 0;
                    document.getElementById('accelerationIndicator').style.display = 'none';
                    break;
            }
        });

        // ÈîÆÁõòÂä†ÈÄüÂ∫¶Á≥ªÁªü
        let keyAcceleration = {
            a: { pressed: false, startTime: 0, acceleration: 0 },
            d: { pressed: false, startTime: 0, acceleration: 0 },
            w: { pressed: false, startTime: 0, acceleration: 0 },
            s: { pressed: false, startTime: 0, acceleration: 0 }
        };
        const ACCELERATION_RATE = 0.5; // Âä†ÈÄüÂ∫¶Â¢ûÂä†ÈÄüÁéá
        const MAX_ACCELERATION = 12.0;    // ÊúÄÂ§ßÂä†ÈÄüÂ∫¶ÂÄº
        const ACCELERATION_DECAY = 0.5; // Âä†ÈÄüÂ∫¶Ë°∞ÂáèÈÄüÁéá
               
        // ÂàùÂßãÂåñÂú∫ÊôØ
        function init() {
            const loadingOverlay = document.getElementById('loadingOverlay');
            
            try {
                // ÂàõÂª∫Âú∫ÊôØ
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0c1e3a);
                scene.fog = new THREE.FogExp2(0x0c1e3a, 0.0004);
                
                // ÂàõÂª∫Áõ∏Êú∫
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 3000);
                camera.position.set(500, 400, 500);
                camera.lookAt(0, 0, 0);
                
                // ÂàõÂª∫Ê∏≤ÊüìÂô® - Ê∑ªÂä†ÂÉèÁ¥†ÊØîÂ§ÑÁêÜ
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    powerPreference: "high-performance"
                });
                
                // ËÆæÁΩÆËÆæÂ§áÂÉèÁ¥†ÊØî
                const pixelRatio = Math.min(window.devicePixelRatio, 2); // ÈôêÂà∂ÊúÄÂ§ßÂÉèÁ¥†ÊØî‰∏∫2
                renderer.setPixelRatio(pixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('gameCanvas').appendChild(renderer.domElement);
                
                // Ê∑ªÂä†ËΩ®ÈÅìÊéßÂà∂
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false;
                controls.minDistance = 100;
                controls.maxDistance = 2500;
                controls.enablePan = true;
                
                // Ê∑ªÂä†ÂÖâÊ∫ê
                const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(600, 700, 600);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
                directionalLight.shadow.mapSize.height = 1024;
                scene.add(directionalLight);
                
                const backLight = new THREE.DirectionalLight(0x2255ff, 0.5);
                backLight.position.set(-400, 350, -400);
                scene.add(backLight);
                
                // ÂàõÂª∫ÁΩëÊ†º
                gridHelper = new THREE.GridHelper(WORLD_SIZE, 100, 0x305080, 0x203050);
                gridHelper.position.y = 0;
                scene.add(gridHelper);
                
                // ÂàõÂª∫ËæπÁïåÊåáÁ§∫
                createBoundaryIndicators();
                
                // ÂàùÂßãÂåñËõáË∫´ÊùêË¥®
                initSnakeMaterials();
                
                // ÂàùÂßãÂåñËõá
                initSnake();
                
                // ÂàõÂª∫È£üÁâ©
                createFoods();
                
                // ÂàõÂª∫ÈöúÁ¢çÁâ©
                createObstacles();
                
                // ÂàõÂª∫AIËõá
                createAISnakes();
                
                // ÂàõÂª∫Â∞èÁêÉËóª
                createAlgae();
                
                // ÂàõÂª∫Êµ∑Â∏¶
                createKelps();
                
                // ÂàõÂª∫ÂèòÂΩ¢Ëô´
                createAmoebas();
                
                // ÂàõÂª∫Á°ÖËóª
                createDiatoms();
                
                // ÂàõÂª∫Â§öÊÆµËô´
                createSegmentedWorms();
                
                // ÂàõÂª∫ÂÖâÊü±ÊåáÁ§∫Á∫ø
                createPathCylinder();
                
                // ÂàùÂßãÂåñÂ∞èÂú∞Âõæ
                initMiniMap();
                
                // Ê∑ªÂä†‰∫ã‰ª∂ÁõëÂê¨Âô®
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);
                document.getElementById('restartBtn').addEventListener('click', resetGame);
                document.getElementById('viewToggleBtn').addEventListener('click', toggleFirstPerson);
                
                // ÊëáÊùÜ‰∫ã‰ª∂
                setupJoystick();
                
                // ÊëáÊùÜÂÆπÂô®ÊãñÂä®‰∫ã‰ª∂
                setupJoystickDrag();
                
                // ÂäüÁéáÊéßÂà∂‰∫ã‰ª∂
                setupPowerControlVertical();
                
                // ÂäüÁéáÈîÅÂÆöÊåâÈíÆ‰∫ã‰ª∂
                document.getElementById('powerLockBtn').addEventListener('click', togglePowerLock);
                
                // Èº†Ê†á‰∫ã‰ª∂ÁõëÂê¨Âô®
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mousedown', function() {
                    if (firstPersonMode) {
                        document.body.requestPointerLock = document.body.requestPointerLock || 
                                                         document.body.mozRequestPointerLock ||
                                                         document.body.webkitRequestPointerLock;
                        document.body.requestPointerLock();
                    }
                });
                
                // Ëß¶Êë∏‰∫ã‰ª∂ÁõëÂê¨Âô®
                setupTouchControls();
                
                // ÁÅµÊïèÂ∫¶ÊéßÂà∂
                document.getElementById('sensitivitySlider').addEventListener('input', function() {
                    touchSensitivity = parseInt(this.value);
                });
                
                // ËÆ∞ÂΩïÊ∏∏ÊàèÂºÄÂßãÊó∂Èó¥
                gameStartTime = Date.now();
                
                // ÈöêËóèÂä†ËΩΩÊèêÁ§∫
                setTimeout(() => {
                    if (loadingOverlay) loadingOverlay.style.display = 'none';
                }, 0);
                
                // ÂºÄÂßãÂä®ÁîªÂæ™ÁéØ
                animate();
                
                // ÂºÄÂßãÁ¨¨‰∏ÄÊ¨°ÁßªÂä®
                startMove();
            } catch (error) {
                console.error("ÂàùÂßãÂåñÈîôËØØ:", error);
                if (loadingOverlay) {
                    loadingOverlay.innerHTML = `
                        <div style="text-align: center; padding: 20px; background: rgba(10,25,50,0.9); border-radius: 10px; max-width: 500px;">
                            <h2 style="color: #ff5555; margin-bottom: 15px;">ÂàùÂßãÂåñÂ§±Ë¥•</h2>
                            <p style="color: #a0d5ff; margin-bottom: 20px;">${error.message || "Êó†Ê≥ïÂàùÂßãÂåñ3DÊ∏≤ÊüìÂô®"}</p>
                            <p style="color: #a0d5ff; margin-bottom: 20px;">ËØ∑Á°Æ‰øùÊÇ®ÁöÑËÆæÂ§áÊîØÊåÅWebGL</p>
                            <button style="background: linear-gradient(45deg, #00ccaa, #00a0ff); 
                                border: none; padding: 12px 30px; border-radius: 50px; 
                                color: white; cursor: pointer; font-size: 1rem;"
                                onclick="location.reload()">ÈáçÊñ∞Âä†ËΩΩ</button>
                        </div>
                    `;
                }
            }
        }
        
        // ÂàõÂª∫Á°ÖËóª
        function createDiatoms() {
            for (let i = 0; i < DIATOM_COUNT; i++) {
                const diatomGroup = new THREE.Group();
                
                // ÂàõÂª∫Á°ÖËóªÂ§ñÂ£≥Ôºà‰ΩøÁî®BufferGeometryÔºâ
                const shellGeometry = new THREE.IcosahedronGeometry(30, 2);
                const shellMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x77ddff,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 80,
                    emissive: 0x4488cc,
                    emissiveIntensity: 0.2,
                    wireframe: false
                });
                
                const shell = new THREE.Mesh(shellGeometry, shellMaterial);
                shell.castShadow = true;
                shell.receiveShadow = true;
                diatomGroup.add(shell);
                
                // ÂàõÂª∫Á°ÖËóªÂÜÖÈÉ®ÔºàÂèØÈ£üÁî®ÈÉ®ÂàÜÔºâ
                const innerGeometry = new THREE.SphereGeometry(20, 16, 16);
                const innerMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffaa77,
                    emissive: 0xcc8855,
                    emissiveIntensity: 0.4
                });
                
                const inner = new THREE.Mesh(innerGeometry, innerMaterial);
                inner.visible = false; // ÂàùÂßã‰∏çÂèØËßÅ
                inner.castShadow = true;
                inner.receiveShadow = true;
                diatomGroup.add(inner);
                
                // ÈöèÊú∫‰ΩçÁΩÆ
                diatomGroup.position.set(
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    Math.floor(Math.random() * 100) - 50,
                    -(Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2)
                );
                
                // ÈöèÊú∫ÊóãËΩ¨
                diatomGroup.rotation.x = Math.random() * Math.PI;
                diatomGroup.rotation.y = Math.random() * Math.PI * 2;
                diatomGroup.rotation.z = Math.random() * Math.PI;
                
                // ËÆæÁΩÆÁ°ÖËóªÂ±ûÊÄß
                diatomGroup.userData = {
                    type: 'diatom',
                    durability: 3, // ËÄê‰πÖÂ∫¶
                    shell: shell,
                    inner: inner,
                    hitCount: 0 // Ë¢´ÊíûÂáªÊ¨°Êï∞
                };
                
                scene.add(diatomGroup);
                diatoms.push(diatomGroup);
            }
        }
        
        // ÂàõÂª∫ÂèòÂΩ¢Ëô´
        function createAmoebas() {
            gltfLoader.load('amoeba.glb', function(gltf) {
                const model = gltf.scene;
                
                for (let i = 0; i < AMOEBA_COUNT; i++) {
                    const amoeba = model.clone();
                    
                    // ËÆæÁΩÆ‰ΩçÁΩÆÔºày=-200Ôºâ
                    amoeba.position.set(
                        Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                        -200,
                        -(Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2)
                    );
                    
                    // ÈöèÊú∫Áº©Êîæ
                    const scale = 0.8 + Math.random() * 0.4;
                    amoeba.scale.set(scale, scale, scale);
                    
                    // ÈöèÊú∫ÊóãËΩ¨
                    amoeba.rotation.x = Math.random() * Math.PI;
                    amoeba.rotation.y = Math.random() * Math.PI * 2;
                    amoeba.rotation.z = Math.random() * Math.PI;
                    
                    // ËÆæÁΩÆÂä®ÁîªÂèÇÊï∞
                    amoeba.userData = {
                        pulseSpeed: 0.5 + Math.random() * 0.5,
                        rotationSpeed: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.01,
                            (Math.random() - 0.5) * 0.01,
                            (Math.random() - 0.5) * 0.01
                        )
                    };
                    
                    scene.add(amoeba);
                    amoebas.push(amoeba);
                }
                
                // Êõ¥Êñ∞ÊåáÁ§∫Âô®
                document.getElementById('amoebaIndicator').textContent = `ÂèòÂΩ¢Ëô´: ${amoebas.length}`;
                document.getElementById('amoebaIndicator').style.display = 'block';
                
            }, undefined, function(error) {
                console.error('Error loading amoeba model', error);
            });
        }
        
        // Êõ¥Êñ∞ÂèòÂΩ¢Ëô´
        function updateAmoebas(timestamp) {
            for (let i = 0; i < amoebas.length; i++) {
                const amoeba = amoebas[i];
                
                // ËÑâÂä®ÊïàÊûú
                const pulse = Math.sin(timestamp * 0.001 * amoeba.userData.pulseSpeed) * 0.1 + 1;
                amoeba.scale.set(pulse, pulse, pulse);
                
                // ÊóãËΩ¨
                amoeba.rotation.x += amoeba.userData.rotationSpeed.x;
                amoeba.rotation.y += amoeba.userData.rotationSpeed.y;
                amoeba.rotation.z += amoeba.userData.rotationSpeed.z;
            }
        }
        
        // Ê£ÄÊü•‰∏éÂèòÂΩ¢Ëô´ÁöÑÁ¢∞Êíû
        function checkAmoebaCollision() {
            const headPos = snake[0].position;
            
            for (let i = amoebas.length - 1; i >= 0; i--) {
                const amoeba = amoebas[i];
                const distance = headPos.distanceTo(amoeba.position);
                
                if (distance < 50) {
                    // Â¢ûÂä†ÂàÜÊï∞
                    score += 200;
                    
                    // Ê∑ªÂä†ËõáË∫´ÊÆµ
                    addSnakeSegment();
                    addSnakeSegment();
                    addSnakeSegment();
                    
                    // ÁßªÈô§ÂèòÂΩ¢Ëô´
                    scene.remove(amoeba);
                    amoebas.splice(i, 1);
                    
                    // Êõ¥Êñ∞ÊåáÁ§∫Âô®
                    document.getElementById('amoebaIndicator').textContent = `ÂèòÂΩ¢Ëô´: ${amoebas.length}`;
                    
                    // Êõ¥Êñ∞UI
                    updateUI();
                    
                    break;
                }
            }
        }
        
        // ÂàõÂª∫Â§öÊÆµËô´
        function createSegmentedWorms() {
            for (let i = 0; i < WORM_COUNT; i++) {
                const wormGroup = new THREE.Group();
                const segments = [];
                const segmentCount = 5 + Math.floor(Math.random() * 4); // 5-8ËäÇ
                
                // ÂàõÂª∫Ëô´Â§¥
                const headGeometry = new THREE.SphereGeometry(12, 16, 16);
                const headMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffaa77,
                    emissive: 0xcc8855,
                    emissiveIntensity: 0.3
                });
                
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.castShadow = true;
                head.receiveShadow = true;
                wormGroup.add(head);
                segments.push(head);
                
                // ÂàõÂª∫Ëô´Ë∫´ËäÇÊÆµ
                for (let j = 1; j < segmentCount; j++) {
                    const segmentGeometry = new THREE.TorusGeometry(8, 4, 8, 16);
                    const segmentMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xffaa77,
                        emissive: 0xcc8855,
                        emissiveIntensity: 0.2
                    });
                    
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    segment.castShadow = true;
                    segment.receiveShadow = true;
                    
                    // ËÆæÁΩÆ‰ΩçÁΩÆÔºàËøûÊé•Âú®Ââç‰∏ÄËäÇÊÆµÂêéÈù¢Ôºâ
                    segment.position.y = -j * 22;
                    wormGroup.add(segment);
                    segments.push(segment);
                }
                
                // ÈöèÊú∫‰ΩçÁΩÆ
                wormGroup.position.set(
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    Math.floor(Math.random() * 200) - 100,
                    -(Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2)
                );
                
                // ÈöèÊú∫ÊñπÂêë
                const direction = new THREE.Vector3(
                    Math.random() - 0.5,
                    Math.random() - 0.5,
                    Math.random() - 0.5
                ).normalize();
                
                // ËÆæÁΩÆÂ§öÊÆµËô´Â±ûÊÄß
                wormGroup.userData = {
                    type: 'segmentedWorm',
                    segments: segments,
                    direction: direction,
                    speed: 0.5 + Math.random() * 0.5,
                    waveOffset: Math.random() * Math.PI * 2,
                    turnCounter: 0,
                    turnInterval: 100 + Math.floor(Math.random() * 100)
                };
                
                scene.add(wormGroup);
                segmentedWorms.push(wormGroup);
            }
        }
        
        // Êõ¥Êñ∞Â§öÊÆµËô´
        function updateSegmentedWorms(timestamp) {
            for (let i = 0; i < segmentedWorms.length; i++) {
                const worm = segmentedWorms[i];
                const segments = worm.userData.segments;
                
                // ÈöèÊú∫ÊîπÂèòÊñπÂêë
                worm.userData.turnCounter++;
                if (worm.userData.turnCounter > worm.userData.turnInterval) {
                    worm.userData.direction = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).normalize();
                    worm.userData.turnCounter = 0;
                    worm.userData.turnInterval = 100 + Math.floor(Math.random() * 100);
                }
                
                // ÁßªÂä®Êï¥‰∏™Ëô´
                worm.position.add(worm.userData.direction.clone().multiplyScalar(worm.userData.speed));
                
                // ËæπÁïåÊ£ÄÊü•
                if (Math.abs(worm.position.x) > WORLD_SIZE/2 - 50) {
                    worm.userData.direction.x *= -1;
                    worm.position.x = Math.sign(worm.position.x) * (WORLD_SIZE/2 - 50);
                }
                if (Math.abs(worm.position.y) > WORLD_SIZE/2 - 50) {
                    worm.userData.direction.y *= -1;
                    worm.position.y = Math.sign(worm.position.y) * (WORLD_SIZE/2 - 50);
                }
                if (Math.abs(worm.position.z) > WORLD_SIZE/2 - 50) {
                    worm.userData.direction.z *= -1;
                    worm.position.z = Math.sign(worm.position.z) * (WORLD_SIZE/2 - 50);
                }
                
                // Ê≥¢Êµ™ÂΩ¢ËøêÂä®
                const waveIntensity = 5;
                const waveSpeed = 0.02;
                
                for (let j = 0; j < segments.length; j++) {
                    if (j > 0) {
                        // Ê≥¢Êµ™ËøêÂä®ÂÅèÁßª
                        const waveOffset = j * 0.5 + worm.userData.waveOffset;
                        const waveX = Math.sin(timestamp * 0.001 * waveSpeed + waveOffset) * waveIntensity;
                        const waveY = Math.cos(timestamp * 0.001 * waveSpeed + waveOffset) * waveIntensity;
                        
                        // Â∫îÁî®Ê≥¢Êµ™ÊïàÊûú
                        segments[j].position.x = waveX;
                        segments[j].position.y = -j * 22 + waveY;
                    }
                    
                    // ÊåáÂêëÂâç‰∏ÄËäÇÊÆµ
                    if (j > 0) {
                        segments[j].lookAt(segments[j-1].position);
                    }
                }
            }
        }
        
        // Ê£ÄÊü•Á°ÖËóªÁ¢∞Êíû
        function checkDiatomCollision() {
            const headPos = snake[0].position;
            
            for (let i = diatoms.length - 1; i >= 0; i--) {
                const diatom = diatoms[i];
                const distance = headPos.distanceTo(diatom.position);
                
                if (distance < 40) {
                    // ÊíûÂáªÁ°ÖËóª
                    diatom.userData.hitCount++;
                    
                    // Êõ¥Êñ∞Â§ñÂ£≥ÊùêË¥®ÊòæÁ§∫Ë£ÇÁ∫πÊïàÊûú
                    const hitRatio = diatom.userData.hitCount / diatom.userData.durability;
                    diatom.userData.shell.material.color = new THREE.Color(
                        0.7 - hitRatio * 0.3,
                        0.7 - hitRatio * 0.5,
                        1.0 - hitRatio * 0.2
                    );
                    
                    // ÊòæÁ§∫Ë£ÇÁ∫πÁ≤íÂ≠êÊïàÊûú
                    createCrackParticles(diatom.position);
                    
                    // Â¶ÇÊûúËÄê‰πÖÂ∫¶ËÄóÂ∞Ω
                    if (diatom.userData.hitCount >= diatom.userData.durability) {
                        // ÊòæÁ§∫ÂÜÖÈÉ®ÂèØÈ£üÁî®ÈÉ®ÂàÜ
                        diatom.userData.inner.visible = true;
                        diatom.userData.shell.visible = false;
                        
                        // Â¢ûÂä†ÂàÜÊï∞
                        score += 100;
                        
                        // Êõ¥Êñ∞UI
                        updateUI();
                    }
                    
                    break;
                }
            }
        }
        
        // ÂàõÂª∫Ë£ÇÁ∫πÁ≤íÂ≠êÊïàÊûú
        function createCrackParticles(position) {
            const particleCount = 20;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                
                // ÈöèÊú∫‰ΩçÁΩÆ
                positions[i3] = position.x + (Math.random() - 0.5) * 20;
                positions[i3 + 1] = position.y + (Math.random() - 0.5) * 20;
                positions[i3 + 2] = position.z + (Math.random() - 0.5) * 20;
                
                // ÈöèÊú∫È¢úËâ≤ÔºàÊµÖËìùËâ≤Ôºâ
                colors[i3] = 0.6 + Math.random() * 0.4;
                colors[i3 + 1] = 0.8 + Math.random() * 0.2;
                colors[i3 + 2] = 1.0;
                
                // ÈöèÊú∫Â§ßÂ∞è
                sizes[i] = 1 + Math.random() * 3;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // ËÆæÁΩÆÁ≤íÂ≠êÊ∂àÂ§±
            setTimeout(() => {
                scene.remove(particles);
            }, 1000);
        }
        
        // Ê£ÄÊü•Â§öÊÆµËô´Á¢∞Êíû
        function checkWormCollision() {
            const headPos = snake[0].position;
            
            for (let i = segmentedWorms.length - 1; i >= 0; i--) {
                const worm = segmentedWorms[i];
                const segments = worm.userData.segments;
                
                for (let j = segments.length - 1; j >= 0; j--) {
                    const segment = segments[j];
                    const distance = headPos.distanceTo(segment.getWorldPosition(new THREE.Vector3()));
                    
                    if (distance < 25) {
                        // Â¶ÇÊûúËô´Âè™Êúâ‰∏ÄËäÇÔºåÂèØ‰ª•È£üÁî®
                        if (segments.length === 1) {
                            // Â¢ûÂä†ÂàÜÊï∞
                            score += 80;
                            
                            // ÁßªÈô§Ëô´
                            scene.remove(worm);
                            segmentedWorms.splice(i, 1);
                            
                            // Êõ¥Êñ∞UI
                            updateUI();
                            
                            break;
                        } 
                        // Âê¶ÂàôÂàÜË£ÇËô´
                        else if (j > 0 && j < segments.length - 1) {
                            splitWorm(worm, j);
                            break;
                        }
                    }
                }
            }
        }
        
        // ÂàÜË£ÇÂ§öÊÆµËô´
        function splitWorm(worm, splitIndex) {
            const segments = worm.userData.segments;
            
            // ÂàõÂª∫Êñ∞Ëô´Ôºà‰ªéÂàÜË£ÇÁÇπÂà∞Â∞æÈÉ®Ôºâ
            const newWormGroup = new THREE.Group();
            const newSegments = [];
            
            // Â§çÂà∂‰ΩçÁΩÆÂíåÊñπÂêë
            newWormGroup.position.copy(worm.position);
            newWormGroup.userData = {
                type: 'segmentedWorm',
                segments: newSegments,
                direction: worm.userData.direction.clone(),
                speed: worm.userData.speed,
                waveOffset: Math.random() * Math.PI * 2,
                turnCounter: 0,
                turnInterval: 100 + Math.floor(Math.random() * 100)
            };
            
            // ÁßªÂä®ËäÇÊÆµÂà∞Êñ∞Ëô´
            for (let i = splitIndex + 1; i < segments.length; i++) {
                worm.remove(segments[i]);
                newWormGroup.add(segments[i]);
                newSegments.push(segments[i]);
            }
            
            // Êõ¥Êñ∞ÂéüËô´ÁöÑËäÇÊÆµ
            worm.userData.segments = segments.slice(0, splitIndex + 1);
            
            // Ê∑ªÂä†Âà∞Âú∫ÊôØÂíåÊï∞ÁªÑ
            scene.add(newWormGroup);
            segmentedWorms.push(newWormGroup);
        }
        
        // Ê£ÄÊü•Á°ÖËóªÂÜÖÈÉ®Á¢∞ÊíûÔºàÈ£üÁî®Ôºâ
        function checkDiatomInnerCollision() {
            const headPos = snake[0].position;
            
            for (let i = diatoms.length - 1; i >= 0; i--) {
                const diatom = diatoms[i];
                
                // Âè™ÊúâÂΩìÂÜÖÈÉ®ÂèØËßÅÊó∂ÊâçÂèØÈ£üÁî®
                if (diatom.userData.inner.visible) {
                    const distance = headPos.distanceTo(diatom.position);
                    
                    if (distance < 30) {
                        // Â¢ûÂä†ÂàÜÊï∞
                        score += 150;
                        
                        // Ê∑ªÂä†ËõáË∫´ÊÆµ
                        addSnakeSegment();
                        addSnakeSegment();
                        addSnakeSegment();
                        
                        // ÁßªÈô§Á°ÖËóª
                        scene.remove(diatom);
                        diatoms.splice(i, 1);
                        
                        // Êõ¥Êñ∞UI
                        updateUI();
                        
                        break;
                    }
                }
            }
        }
        
        // ËÆæÁΩÆËß¶Êë∏ÊéßÂà∂
        function setupTouchControls() {
            const touchLeft = document.getElementById('touchLeft');
            const touchRight = document.getElementById('touchRight');
            
            touchLeft.addEventListener('touchstart', onTouchStart);
            touchLeft.addEventListener('touchmove', onTouchMove);
            touchLeft.addEventListener('touchend', onTouchEnd);
            
            touchRight.addEventListener('touchstart', onTouchStart);
            touchRight.addEventListener('touchmove', onTouchMove);
            touchRight.addEventListener('touchend', onTouchEnd);
        }
        
        // Ëß¶Êë∏ÂºÄÂßã
        function onTouchStart(e) {
            if (!firstPersonMode || !gameRunning) return;
            
            isTouching = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchLastX = touch.clientX;
            touchLastY = touch.clientY;
        }
        
        // Ëß¶Êë∏ÁßªÂä®
        function onTouchMove(e) {
            if (!isTouching || !firstPersonMode || !gameRunning) return;
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - touchLastX;
            const deltaY = touch.clientY - touchLastY;
            
            touchLastX = touch.clientX;
            touchLastY = touch.clientY;
            
            // Ê†πÊçÆÁÅµÊïèÂ∫¶Ë∞ÉÊï¥
            const sensitivity = touchSensitivity * 0.001;
            
            // Êõ¥Êñ∞Ê∞¥Âπ≥ËßíÂ∫¶
            horizontalAngle += deltaX * sensitivity;
            
            // Êõ¥Êñ∞ÂûÇÁõ¥ËßíÂ∫¶Âπ∂ÈôêÂà∂ËåÉÂõ¥
            joystickPower -= deltaY * sensitivity;
            joystickPower = Math.max(0, Math.min(1, joystickPower));
           
            
            // Êõ¥Êñ∞ÊñπÂêëÂêëÈáè
            updateDirectionVector();
            
            // Êõ¥Êñ∞ÂäüÁéáÊéßÂà∂ÊòæÁ§∫
            updatePowerControl();
            
            // Êõ¥Êñ∞ÊëáÊùÜÊòæÁ§∫
            updateJoystickDisplay();
        }
        
        // Ëß¶Êë∏ÁªìÊùü
        function onTouchEnd() {
            isTouching = false;
        }
        
        // Èº†Ê†áÁßªÂä®‰∫ã‰ª∂Â§ÑÁêÜ
        function onMouseMove(event) {
            if (!firstPersonMode || !gameRunning) return;
            
            // ËÆ°ÁÆóÈº†Ê†áÁßªÂä®Èáè
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            
            // Êõ¥Êñ∞Ê∞¥Âπ≥ËßíÂ∫¶
            horizontalAngle += movementX * MOUSE_SENSITIVITY;
            
            // Êõ¥Êñ∞ÂûÇÁõ¥ËßíÂ∫¶Âπ∂ÈôêÂà∂ËåÉÂõ¥
            joystickPower = Math.max(0, Math.min(1, joystickPower - movementY * MOUSE_SENSITIVITY));
            
            // Êõ¥Êñ∞ÊñπÂêëÂêëÈáè
            updateDirectionVector();
            
            // Êõ¥Êñ∞ÂÖâÊü±ÊñπÂêëÊåáÁ§∫Âô®
            updateBeamIndicator();
        }
        
        // Êõ¥Êñ∞ÂÖâÊü±ÊñπÂêëÊåáÁ§∫Âô®
        function updateBeamIndicator() {
            const beamIndicator = document.getElementById('beamDirection');
            const angleDeg = Math.round((horizontalAngle * 180 / Math.PI + 360) % 360);
            const powerPercent = Math.round(joystickPower * 100);
            const elevationAngle = Math.round(targetVerticalAngle * 180 / Math.PI);
            
            beamIndicator.textContent = `ÂÖâÊü±ÊñπÂêë: ${angleDeg}¬∞ | ÂäüÁéá: ${powerPercent}% | ‰ª∞Ëßí: ${elevationAngle}¬∞`;
        }
        
        // ÂàáÊç¢Á¨¨‰∏Ä‰∫∫Áß∞Ê®°Âºè
        function toggleFirstPerson() {
            firstPersonMode = !firstPersonMode;
            const btn = document.getElementById('viewToggleBtn');
            const indicator = document.getElementById('fpIndicator');
            const beamIndicator = document.getElementById('beamDirection');
            const crosshair = document.getElementById('crosshair');
            const touchControls = document.getElementById('touchControls');
            
            if (firstPersonMode) {
                btn.textContent = "üé•V";
                btn.style.backgroundColor = "rgba(20, 60, 120, 0.9)";
                indicator.style.display = 'block';
                beamIndicator.style.display = 'block';
                crosshair.style.display = 'block';
                touchControls.style.display = 'block';
                
                
                // Âú®Á¨¨‰∏Ä‰∫∫Áß∞Ê®°Âºè‰∏ãÈöêËóèËõáÂ§¥
                if (snake.length > 0) {
                    snake[0].visible = false;
                }
                
                // Á¶ÅÁî®ËΩ®ÈÅìÊéßÂà∂
                controls.enabled = false;
                
                // ÂàáÊç¢ÂÖâÊü±ÊùêË¥®‰∏∫Á∫øÊ°Ü
                if (pathCylinder) {
                    pathCylinder.material = pathCylinderWireMaterial;
                }
                
                // ËØ∑Ê±ÇÊåáÈíàÈîÅÂÆö
                if ('requestPointerLock' in document.body) {
                    document.body.requestPointerLock();
                }
            } else {
                btn.textContent = "üëÅÔ∏èV";
                btn.style.backgroundColor = "rgba(10, 25, 50, 0.8)";
                indicator.style.display = 'none';
                beamIndicator.style.display = 'none';
                crosshair.style.display = 'none';
                touchControls.style.display = 'none';
                
                // Âú®Á¨¨‰∏â‰∫∫Áß∞Ê®°Âºè‰∏ãÊòæÁ§∫ËõáÂ§¥
                if (snake.length > 0) {
                    snake[0].visible = true;
                }
                
                // ÂêØÁî®ËΩ®ÈÅìÊéßÂà∂
                controls.enabled = true;
                
                // ÂàáÊç¢ÂÖâÊü±ÊùêË¥®‰∏∫ÂÆûÂøÉ
                if (pathCylinder) {
                    pathCylinder.material = pathCylinderSolidMaterial;
                }
                
                // ÈÄÄÂá∫ÊåáÈíàÈîÅÂÆö
                if ('exitPointerLock' in document) {
                    document.exitPointerLock();
            }
            }
            
            // Êõ¥Êñ∞ÂÖâÊü±ÊåáÁ§∫Âô®
            updateBeamIndicator();
        }
        
        // Êõ¥Êñ∞Á¨¨‰∏Ä‰∫∫Áß∞Áõ∏Êú∫
        function updateFirstPersonCamera() {
            if (!snake.length) return;
            
            const head = snake[0];
            
            // ËÆæÁΩÆÁõ∏Êú∫‰ΩçÁΩÆÂú®ËõáÂ§¥ÂâçÊñπ
            const offset = direction.clone().multiplyScalar(30); // 30Âçï‰ΩçÂâçÊñπ
            camera.position.copy(head.position).add(offset);
            
            // ËÆæÁΩÆÁõ∏Êú∫ÊúùÂêë‰∏éËõáÂâçËøõÊñπÂêëÁõ∏Âêå
            camera.lookAt(head.position.clone().add(direction.clone().multiplyScalar(100)));
            
            // Êõ¥Êñ∞ÂÖâÊü±ÊñπÂêëÊåáÁ§∫Âô®
            const beamIndicator = document.getElementById('beamDirection');
            const angleDeg = Math.round((horizontalAngle * 180 / Math.PI + 360) % 360);
            const powerPercent = Math.round(joystickPower * 100);
            const elevationAngle = Math.round(verticalAngle * 180 / Math.PI);
            
            beamIndicator.textContent = `ÂÖâÊü±ÊñπÂêë: ${angleDeg}¬∞ | ÂäüÁéá: ${powerPercent}% | ‰ª∞Ëßí: ${elevationAngle}¬∞`;
        }
        
        // ËÆæÁΩÆÂûÇÁõ¥ÂäüÁéáÊéßÂà∂
        function setupPowerControlVertical() {
            const powerSlider = document.getElementById('powerSliderVertical');
            const powerIndicator = document.getElementById('powerIndicatorVertical');
            const powerGear = document.getElementById('powerGear');
            
            // ÂäüÁéáÊªëÂùó‰∫ã‰ª∂
            powerSlider.addEventListener('input', function() {
                let rawValue = parseInt(this.value);
                
                // Âú®0.5ÂäüÁéáÈôÑËøëÊ∑ªÂä†Âê∏ÈôÑÊïàÊûú (48-52‰πãÈó¥Âê∏ÈôÑÂà∞50)
                if (rawValue >= 48 && rawValue <= 52) {
                    rawValue = 50;
                    this.value = 50;
                }
                
                joystickPower = rawValue / 100;
                
                // Êõ¥Êñ∞ÂäüÁéáÊåáÁ§∫Âô®
                powerIndicator.textContent = joystickPower.toFixed(2);
                
                
                
                // Êõ¥Êñ∞Ê°£ÊääÈ¢úËâ≤
                updateGearColor();
                
                // Êõ¥Êñ∞ÊëáÊùÜÊòæÁ§∫
                updateJoystickDisplay();
            });
            
            // ÂàùÂßãÂåñÊ°£ÊääÈ¢úËâ≤
            updateGearColor();
        }
        
        // ÂàáÊç¢ÂäüÁéáÈîÅÂÆöÁä∂ÊÄÅ
        function togglePowerLock() {
            const lockBtn = document.getElementById('powerLockBtn');
            powerLocked = !powerLocked;
            
            if (powerLocked) {
                lockBtn.classList.add('locked');
                lockBtn.textContent = 'üîí';
            } else {
                lockBtn.classList.remove('locked');
                lockBtn.textContent = 'üîì';
            }
        }
        
        // Êõ¥Êñ∞Ê°£ÊääÈ¢úËâ≤
        function updateGearColor() {
            const powerGear = document.getElementById('powerGear');
            if (!powerGear) return;
            
            // Ê†πÊçÆÂäüÁéáÂÄºËÆæÁΩÆ‰∏çÂêåÈ¢úËâ≤
            if (joystickPower < 0.3) {
                powerGear.style.background = 'linear-gradient(45deg, #ff5555, #ff9966)';
            } else if (joystickPower < 0.7) {
                powerGear.style.background = 'linear-gradient(45deg, #44aa66, #66cc88)';
            } else {
                powerGear.style.background = 'linear-gradient(45deg, #0066cc, #0099ff)';
            }
        }
        
        // Êõ¥Êñ∞ÊëáÊùÜÊòæÁ§∫
        function updateJoystickDisplay() {
            const joystickStats = document.querySelector('.joystick-stats');
            if (!joystickStats) return;
            
            const angleDeg = Math.round((horizontalAngle * 180 / Math.PI + 360) % 360);
            const powerPercent = Math.round(joystickPower * 100);
            
            joystickStats.innerHTML = `${angleDeg}¬∞<br>${powerPercent}%`;
        }
        
        // ÂàõÂª∫AIËõá
        function createAISnakes() {
            for (let i = 0; i < AI_SNAKE_COUNT; i++) {
                const aiSnake = {
                    body: [],
                    direction: new THREE.Vector3(
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1
                    ).normalize(),
                    length: 3,
                    positionHistory: [],
                    color: new THREE.Color(0xffaa00),
                    speed: Math.random() * 0.5 + 0.8,
                    turnCounter: 0,
                    turnInterval: Math.floor(Math.random() * 100) + 50
                };
                
                // ÂàõÂª∫AIËõáÂ§¥
                const headGeometry = new THREE.BoxGeometry(10, 10, 10);
                const headMaterial = new THREE.MeshPhongMaterial({ 
                    color: aiSnake.color,
                    emissive: 0xaa5500,
                    emissiveIntensity: 0.3
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                
                // ÈöèÊú∫‰ΩçÁΩÆ
                head.position.set(
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    -(Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2)
                );
                
                head.castShadow = true;
                head.receiveShadow = true;
                scene.add(head);
                aiSnake.body.push(head);
                
                // ÂàõÂª∫ÂàùÂßãËõáË∫´
                for (let j = 1; j < aiSnake.length; j++) {
                    const segmentGeometry = new THREE.BoxGeometry(9, 9, 9);
                    const segmentMaterial = new THREE.MeshPhongMaterial({ 
                        color: aiSnake.color,
                        emissive: 0xaa5500,
                        emissiveIntensity: 0.2
                    });
                    const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
                    
                    segment.position.copy(head.position);
                    segment.position.x -= aiSnake.direction.x * 10 * j;
                    segment.position.y -= aiSnake.direction.y * 10 * j;
                    segment.position.z -= aiSnake.direction.z * 10 * j;
                    
                    segment.castShadow = true;
                    segment.receiveShadow = true;
                    scene.add(segment);
                    aiSnake.body.push(segment);
                }
                
                aiSnakes.push(aiSnake);
            }
        }
        
        // ÂàõÂª∫Â∞èÁêÉËóª
        function createAlgae() {
            for (let i = 0; i < ALGAE_COUNT; i++) {
                const algaeGroup = new THREE.Group();
                
                // ÂàõÂª∫Â∞èÁêÉËóª‰∏ª‰Ωì
                const mainGeometry = new THREE.SphereGeometry(12, 8, 8);
                mainGeometry.scale(
                    0.8 + Math.random() * 0.4,
                    0.8 + Math.random() * 0.4,
                    0.8 + Math.random() * 0.4
                );
                
                // Á≤óÁ≥ôÊùêË¥®
                const algaeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x55ff55,
                    transparent: true,
                    opacity: 0.7,
                    shininess: 20,
                    roughness: 0.9,
                    emissive: 0x22aa22,
                    emissiveIntensity: 0.3
                });
                
                const algaeMesh = new THREE.Mesh(mainGeometry, algaeMaterial);
                algaeMesh.castShadow = true;
                algaeMesh.receiveShadow = true;
                algaeGroup.add(algaeMesh);
                
                // Ê∑ªÂä†ÁµÆÁä∂ÊïàÊûú
                const fluffCount = 2 + Math.floor(Math.random() * 8);
                for (let j = 0; j < fluffCount; j++) {
                    const fluffGeometry = new THREE.SphereGeometry(
                        2 + Math.random() * 4, 
                        6, 
                        6
                    );
                    
                    // ÈöèÊú∫‰ΩçÁΩÆÂÅèÁßª
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 25,
                        (Math.random() - 0.5) * 25,
                        (Math.random() - 0.5) * 25
                    );
                    
                    const fluffMesh = new THREE.Mesh(fluffGeometry, algaeMaterial);
                    fluffMesh.position.copy(offset);
                    fluffMesh.castShadow = true;
                    fluffMesh.receiveShadow = true;
                    algaeGroup.add(fluffMesh);
                }
                
                // ÈöèÊú∫‰ΩçÁΩÆ
                algaeGroup.position.set(
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    -(Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2)
                );
                
                // ÈöèÊú∫ÊºÇÊµÆÈÄüÂ∫¶
                algaeGroup.userData = {
                    speed: Math.random() * 0.5 + 0.2,
                    direction: new THREE.Vector3(
                        Math.random() * 0.1 - 0.05,
                        Math.random() * 0.1 - 0.05,
                        Math.random() * 0.1 - 0.05
                    ),
                    rotationSpeed: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.01,
                        (Math.random() - 0.5) * 0.01,
                        (Math.random() - 0.5) * 0.01
                    )
                };
                
                scene.add(algaeGroup);
                algae.push(algaeGroup);
            }
        }
        
        // ÂàõÂª∫Êµ∑Â∏¶
        function createKelps() {
            for (let i = 0; i < KELP_COUNT; i++) {
                const kelpGroup = new THREE.Group();
                
                // ÂàõÂª∫Êµ∑Â∏¶Ëåé
                const stemGeometry = new THREE.CylinderGeometry(1.8, 2.0, 100, 12, 32);
                const stemMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x5533cc,
                    shininess: 60,
                    emissive: 0x331188,
                    emissiveIntensity: 0.3
                });
                
                // Êâ≠Êõ≤ËåéÂπ≤
                const positionAttribute = stemGeometry.attributes.position;
                for (let j = 0; j < positionAttribute.count; j++) {
                    const y = positionAttribute.getY(j);
                    const twistAmount = Math.sin(y * 0.1) * 7;
                    positionAttribute.setX(j, positionAttribute.getX(j) + twistAmount);
                }
                
                const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                stem.position.y = 50;
                kelpGroup.add(stem);
                
                // ÂàõÂª∫Âè∂ÁâáÊùêË¥®
                const leafMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x8855ff,
                    shininess: 40,
                    emissive: 0x5533cc,
                    emissiveIntensity: 0.2,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.85
                });
                
                // ÂàõÂª∫Â§öÂ±ÇÂè∂Áâá
                for (let j = 0; j < 6; j++) {
                    const layerHeight = j * 15;
                    
                    // ÂàõÂª∫‰∏ªÂè∂Áâá
                    const leafGeometry = new THREE.PlaneGeometry(35, 16, 16, 4);
                    
                    // ÂºØÊõ≤Âè∂Áâá
                    const positions = leafGeometry.attributes.position.array;
                    for (let k = 0; k < positions.length; k += 3) {
                        const y = positions[k + 1];
                        const bend = Math.sin((y + 8) * 0.3) * 8;
                        positions[k] += bend;
                    }
                    leafGeometry.attributes.position.needsUpdate = true;
                    
                    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                    leaf.position.y = layerHeight;
                    leaf.rotation.x = Math.PI / 2;
                    
                    // ÈöèÊú∫ÊóãËΩ¨ËßíÂ∫¶
                    const rotationAngle = (j % 2 === 0 ? 1 : -1) * (Math.PI / 4 + Math.random() * 0.2);
                    leaf.rotation.z = rotationAngle;
                    
                    // Â≠òÂÇ®ÂéüÂßãÂÄºÁî®‰∫éÂä®Áîª
                    leaf.userData = {
                        originalX: leaf.position.x,
                        originalY: leaf.position.y,
                        originalRotationZ: leaf.rotation.z
                    };
                    
                    kelpGroup.add(leaf);
                    
                    // Ê∑ªÂä†ÂØπÁß∞Âè∂Áâá
                    const leaf2 = leaf.clone();
                    leaf2.rotation.z = -rotationAngle;
                    
                    // Â≠òÂÇ®ÂéüÂßãÂÄº
                    leaf2.userData = {
                        originalX: leaf2.position.x,
                        originalY: leaf2.position.y,
                        originalRotationZ: leaf2.rotation.z
                    };
                    
                    kelpGroup.add(leaf2);
                    
                    // Ê∑ªÂä†Â∞èÂûã‰æßÂè∂
                    for (let s = 0; s < 2; s++) {
                        const sideLeafGeometry = new THREE.PlaneGeometry(15, 8, 8, 2);
                        
                        // ÂºØÊõ≤‰æßÂè∂
                        const sidePositions = sideLeafGeometry.attributes.position.array;
                        for (let k = 0; k < sidePositions.length; k += 3) {
                            const y = sidePositions[k + 1];
                            const bend = Math.sin((y + 4) * 0.4) * 4;
                            sidePositions[k] += bend;
                        }
                        sideLeafGeometry.attributes.position.needsUpdate = true;
                        
                        const sideLeaf = new THREE.Mesh(sideLeafGeometry, leafMaterial);
                        sideLeaf.position.y = layerHeight + 5;
                        sideLeaf.position.x = (s === 0 ? -1 : 1) * 15;
                        sideLeaf.rotation.x = Math.PI / 2;
                        sideLeaf.rotation.z = (s === 0 ? 1 : -1) * (Math.PI / 3 + Math.random() * 0.2);
                        
                        // Â≠òÂÇ®ÂéüÂßãÂÄº
                        sideLeaf.userData = {
                            originalX: sideLeaf.position.x,
                            originalY: sideLeaf.position.y,
                            originalRotationZ: sideLeaf.rotation.z
                        };
                        
                        kelpGroup.add(sideLeaf);
                    }
                }
                
                // Ê∑ªÂä†È°∂ÈÉ®Ë£ÖÈ•∞
                const topGeometry = new THREE.ConeGeometry(4, 12, 8);
                const topMaterial = new THREE.MeshPhongMaterial({
                    color: 0xaa77ff,
                    emissive: 0x7744dd,
                    emissiveIntensity: 0.3,
                    shininess: 50
                });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.y = 100;
                kelpGroup.add(top);
                
                // ÈöèÊú∫‰ΩçÁΩÆ
                kelpGroup.position.set(
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    Math.floor(Math.random() * 100) - 50,
                    -(Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2)
                );
                
                // ÈöèÊú∫Áº©Êîæ
                const scale = 0.7 + Math.random() * 0.6;
                kelpGroup.scale.set(scale, scale, scale);
                
                kelpGroup.castShadow = true;
                kelpGroup.receiveShadow = true;
                
                // ÊëÜÂä®ÂèÇÊï∞
                kelpGroup.userData = {
                    baseRotation: Math.random() * Math.PI * 2,
                    swingSpeed: Math.random() * 0.01 + 0.02,
                    swingAmplitude: Math.random() * 0.3 + 0.2,
                    leafWaveOffset: Math.random() * Math.PI * 2,
                    timeOffset: Math.random() * 1000
                };
                
                scene.add(kelpGroup);
                kelps.push(kelpGroup);
                
                // Ê∑ªÂä†Ê∞îÊ≥°ÊïàÊûú
                createBubblesAroundKelp(kelpGroup);
            }
        }
        
        // Âú®Êµ∑Â∏¶Âë®Âõ¥ÂàõÂª∫Ê∞îÊ≥°
        function createBubblesAroundKelp(kelp) {
            const bubbleGroup = new THREE.Group();
            const bubbleMaterial = new THREE.MeshPhongMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.6,
                shininess: 100,
                emissive: 0x4488ff,
                emissiveIntensity: 0.3
            });
            
            // ÂàõÂª∫Â§ö‰∏™Ê∞îÊ≥°
            for (let i = 0; i < 8; i++) {
                const bubbleGeometry = new THREE.SphereGeometry(1.5 + Math.random() * 1, 8, 8);
                const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                
                // ÈöèÊú∫‰ΩçÁΩÆ
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 10;
                const height = Math.random() * 80;
                
                bubble.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                bubble.castShadow = true;
                bubble.receiveShadow = true;
                bubble.userData = {
                    speed: 0.5 + Math.random() * 0.1,
                    startHeight: height,
                    amplitude: 0.5 + Math.random(),
                    offset: Math.random() * Math.PI * 2
                };
                
                bubbleGroup.add(bubble);
            }
            
            kelp.add(bubbleGroup);
        }
        
        // ÂàõÂª∫ÂÖâÊü±ÊåáÁ§∫Á∫ø
        function createPathCylinder() {
            const cylinderGeometry = new THREE.CylinderGeometry(8, 8, 1, 16);
            
            // ÂÆûÂøÉÊùêË¥®
            pathCylinderSolidMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.4,
                emissive: 0x00ffaa,
                emissiveIntensity: 0.3,
                side: THREE.DoubleSide
            });
            
            // Á∫øÊ°ÜÊùêË¥®ÔºàÁî®‰∫éÁ¨¨‰∏Ä‰∫∫Áß∞Ê®°ÂºèÔºâ
            pathCylinderWireMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffaa,
                wireframe: true,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            
            pathCylinder = new THREE.Mesh(cylinderGeometry, pathCylinderSolidMaterial);
            pathCylinder.rotation.x = Math.PI / 2;
            scene.add(pathCylinder);
        }
        
        // Êõ¥Êñ∞ÂÖâÊü±ÊåáÁ§∫Á∫ø
        function updatePathCylinder() {
            if (!snake.length) return;
            
            const head = snake[0];
            const headPos = head.position;
            
            // ËÆ°ÁÆóÂÖâÊü±ÊñπÂêë
            const directionVector = direction.clone().normalize();
            
            // ËÆ°ÁÆóÂÖâÊü±ÈïøÂ∫¶
            const distanceToBoundary = Math.min(
                (WORLD_SIZE/2 - Math.abs(headPos.x)) / Math.abs(directionVector.x),
                (WORLD_SIZE/2 - Math.abs(headPos.y)) / Math.abs(directionVector.y),
                (WORLD_SIZE/2 - Math.abs(headPos.z)) / Math.abs(directionVector.z)
            );
            
            const cylinderLength = Math.min(distanceToBoundary, WORLD_SIZE);
            
            // Êõ¥Êñ∞ÂÖâÊü±‰ΩçÁΩÆÂíåÂ∞∫ÂØ∏
            pathCylinder.scale.set(1, cylinderLength, 1);
            pathCylinder.position.copy(headPos);
            pathCylinder.position.add(directionVector.clone().multiplyScalar(cylinderLength/2));
            
            // ÊóãËΩ¨ÂÖâÊü±‰ª•ÂåπÈÖçÊñπÂêë
            pathCylinder.lookAt(headPos.clone().add(directionVector.clone().multiplyScalar(100)));
            pathCylinder.rotateX(Math.PI / 2);
        }
        
        // ËÆæÁΩÆÊëáÊùÜÂäüËÉΩ
        function setupJoystick() {
            const joystickHead = document.getElementById('joystickHead');
            const joystickContainer = document.getElementById('joystickContainer');
            const directionIndicator = document.getElementById('directionIndicator');
            
            let startX, startY;
            let baseRect;
            
            // Ëß¶Êë∏ÂºÄÂßã
            joystickHead.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickHead.getBoundingClientRect();
                startX = touch.clientX - rect.left - rect.width/2;
                startY = touch.clientY - rect.top - rect.height/2;
                baseRect = joystickContainer.getBoundingClientRect();
                joystickActive = true;
                joystickContainer.classList.add('active');
            });
            
            // Ëß¶Êë∏ÁßªÂä®
            document.addEventListener('touchmove', (e) => {
                if (!joystickActive) return;
                e.preventDefault();
                
                const touch = e.touches[0];
                const centerX = baseRect.left + baseRect.width/2;
                const centerY = baseRect.top + baseRect.height/2;
                
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                
                // ËÆ°ÁÆóË∑ùÁ¶ªÂíåËßíÂ∫¶
                const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), baseRect.width/2);
                joystickAngle = Math.atan2(deltaY, deltaX);
              
                // Âú®ÂäüÁéáÊú™ÈîÅÂÆöÊó∂Êõ¥Êñ∞ÂäüÁéá
                if (!powerLocked) {
                    joystickPower = distance / (baseRect.width/2);
                }
                
                // Êõ¥Êñ∞ÊëáÊùÜÂ§¥‰ΩçÁΩÆ
                const offsetX = distance * Math.cos(joystickAngle);
                const offsetY = distance * Math.sin(joystickAngle);
                
                joystickHead.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                
                // Êõ¥Êñ∞ÊñπÂêëÊåáÁ§∫
                const angleDeg = Math.round((joystickAngle * 180 / Math.PI + 360) % 360);
                directionIndicator.textContent = `‚Üë ${angleDeg}¬∞`;
                
                // Êõ¥Êñ∞Ê∏∏ÊàèÊñπÂêë
                horizontalAngle = joystickAngle + Math.PI/2;
                verticalAngle = Math.max(-Math.PI/3, Math.min(Math.PI/3, (joystickPower - 0.5) * Math.PI/3));
                updateDirectionVector();
                
                // Êõ¥Êñ∞ÂäüÁéáÊéßÂà∂
                if (!powerLocked) {
                    updatePowerControl();
                }
                
                // Êõ¥Êñ∞ÊëáÊùÜÊòæÁ§∫
                updateJoystickDisplay();
            });
            
            // Ëß¶Êë∏ÁªìÊùü
            document.addEventListener('touchend', () => {
                if (!joystickActive) return;
                joystickActive = false;
                joystickContainer.classList.remove('active');
                // ‰øùÊåÅÊëáÊùÜÂú®ÂΩìÂâç‰ΩçÁΩÆÔºå‰∏çÈáçÁΩÆ
                directionIndicator.textContent = '';
            });
            
            // Èº†Ê†á‰∫ã‰ª∂
            joystickHead.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const rect = joystickHead.getBoundingClientRect();
                startX = e.clientX - rect.left - rect.width/2;
                startY = e.clientY - rect.top - rect.height/2;
                baseRect = joystickContainer.getBoundingClientRect();
                joystickActive = true;
                joystickContainer.classList.add('active');
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!joystickActive) return;
                e.preventDefault();
                
                const centerX = baseRect.left + baseRect.width/2;
                const centerY = baseRect.top + baseRect.height/2;
                
                const deltaX = e.clientX - centerX;
                const deltaY = e.clientY - centerY;
                
                // ËÆ°ÁÆóË∑ùÁ¶ªÂíåËßíÂ∫¶
                const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), baseRect.width/2);
                joystickAngle = Math.atan2(deltaY, deltaX);
                
                // Âú®ÂäüÁéáÊú™ÈîÅÂÆöÊó∂Êõ¥Êñ∞ÂäüÁéá
                if (!powerLocked) {
                    joystickPower = distance / (baseRect.width/2);
                }
                
                // Êõ¥Êñ∞ÊëáÊùÜÂ§¥‰ΩçÁΩÆ
                const offsetX = distance * Math.cos(joystickAngle);
                const offsetY = distance * Math.sin(joystickAngle);
                
                joystickHead.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                
                // Êõ¥Êñ∞ÊñπÂêëÊåáÁ§∫
                const angleDeg = Math.round((joystickAngle * 180 / Math.PI + 360) % 360);
                directionIndicator.textContent = `‚Üë ${angleDeg}¬∞`;
                
                // Êõ¥Êñ∞Ê∏∏ÊàèÊñπÂêë
                horizontalAngle = joystickAngle + Math.PI/2;
                verticalAngle = Math.max(-Math.PI/2, Math.min(Math.PI/2, (joystickPower - 0.5) * Math.PI/2));
                updateDirectionVector();
                
                // Êõ¥Êñ∞ÂäüÁéáÊéßÂà∂
                if (!powerLocked) {
                    updatePowerControl();
                }
                
                // Êõ¥Êñ∞ÊëáÊùÜÊòæÁ§∫
                updateJoystickDisplay();
            });
            
            document.addEventListener('mouseup', () => {
                if (!joystickActive) return;
                joystickActive = false;
                joystickContainer.classList.remove('active');
                directionIndicator.textContent = '';
            });
        }
        
        // Êõ¥Êñ∞ÂäüÁéáÊéßÂà∂
        function updatePowerControl() {
            const powerSlider = document.getElementById('powerSliderVertical');
            const powerIndicator = document.getElementById('powerIndicatorVertical');
            
            if (powerSlider && powerIndicator) {
                // Êõ¥Êñ∞ÊªëÂùó‰ΩçÁΩÆ
                powerSlider.value = Math.round(joystickPower * 100);
                
                // Êõ¥Êñ∞ÂäüÁéáÊåáÁ§∫Âô®
                powerIndicator.textContent = joystickPower.toFixed(2);
                
                // Êõ¥Êñ∞Ê°£ÊääÈ¢úËâ≤
                updateGearColor();
            }
        }
        
        // ÂàùÂßãÂåñÂ∞èÂú∞Âõæ
        function initMiniMap() {
            const miniMap = document.getElementById('miniMap');
            // ‰ΩøÁî®ÂÆπÂô®Â∞∫ÂØ∏‰Ωú‰∏∫ÂèÇËÄÉ
            const container = document.querySelector('.mini-map-container');
            const size = Math.min(container.clientWidth, container.clientHeight);
            
            // ËÆæÁΩÆÂÉèÁ¥†ÊØî
            const pixelRatio = Math.min(window.devicePixelRatio, 2);
            miniMap.width = size * pixelRatio;
            miniMap.height = size * pixelRatio;
            miniMap.style.width = size + 'px';
            miniMap.style.height = size + 'px';
            
            miniMapCtx = miniMap.getContext('2d');
        }
        
        // Êõ¥Êñ∞Â∞èÂú∞Âõæ
        function updateMiniMap() {
            if (!miniMapCtx || snake.length === 0) return;
            
            const head = snake[0];
            const headY = head.position.y;
            
            // Ê∏ÖÁ©∫ÁîªÂ∏É
            miniMapCtx.clearRect(0, 0, miniMapCtx.canvas.width, miniMapCtx.canvas.height);
            
            // Âä®ÊÄÅËÆ°ÁÆóÁº©ÊîæÊØî‰æã
            const scale = miniMapCtx.canvas.width / WORLD_SIZE;
            
            // ÁªòÂà∂ÁΩëÊ†º
            miniMapCtx.strokeStyle = 'rgba(100, 180, 255, 0.3)';
            miniMapCtx.lineWidth = 1;
            
            const gridSize = 10;
            const mapSize = miniMapCtx.canvas.width;
            for (let i = 0; i <= gridSize; i++) {
                const pos = i * (mapSize / gridSize);
                miniMapCtx.beginPath();
                miniMapCtx.moveTo(pos, 0);
                miniMapCtx.lineTo(pos, mapSize);
                miniMapCtx.stroke();
                
                miniMapCtx.beginPath();
                miniMapCtx.moveTo(0, pos);
                miniMapCtx.lineTo(mapSize, pos);
                miniMapCtx.stroke();
            }
            
            // ÁªòÂà∂ËæπÁïå
            miniMapCtx.strokeStyle = 'rgba(0, 200, 255, 0.5)';
            miniMapCtx.lineWidth = 2;
            miniMapCtx.strokeRect(0, 0, mapSize, mapSize);
            
            // ÁªòÂà∂È£üÁâ©
            for (let food of foods) {
                if (Math.abs(food.position.y - headY) > Y_THRESHOLD) continue;
                
                const x = (food.position.x + WORLD_SIZE/2) * scale;
                const z = mapSize - ((-food.position.z) + WORLD_SIZE/2) * scale;
                
                if (x >= 0 && x <= mapSize && z >= 0 && z <= mapSize) {
                    miniMapCtx.fillStyle = '#ff5555';
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(x, z, 2, 0, Math.PI * 2);
                    miniMapCtx.fill();
                }
            }
            
            // ÁªòÂà∂ÈöúÁ¢çÁâ©
            for (let obstacle of obstacles) {
                if (Math.abs(obstacle.position.y - headY) > Y_THRESHOLD) continue;
                
                const x = (obstacle.position.x + WORLD_SIZE/2) * scale;
                const z = mapSize - ((-obstacle.position.z) + WORLD_SIZE/2) * scale;
                
                if (x >= 0 && x <= mapSize && z >= 0 && z <= mapSize) {
                    miniMapCtx.fillStyle = '#000000';
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(x, z, 3, 0, Math.PI * 2);
                    miniMapCtx.fill();
                }
            }
            
            // ÁªòÂà∂AIËõá
            for (let aiSnake of aiSnakes) {
                if (aiSnake.body.length === 0) continue;
                
                const aiHead = aiSnake.body[0];
                if (Math.abs(aiHead.position.y - headY) > Y_THRESHOLD) continue;
                
                const aiX = (aiHead.position.x + WORLD_SIZE/2) * scale;
                const aiZ = mapSize - ((-aiHead.position.z) + WORLD_SIZE/2) * scale;
                
                if (aiX >= 0 && aiX <= mapSize && aiZ >= 0 && aiZ <= mapSize) {
                    miniMapCtx.fillStyle = '#ffaa00';
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(aiX, aiZ, 3, 0, Math.PI * 2);
                    miniMapCtx.fill();
                }
            }
            
            // ÁªòÂà∂Â∞èÁêÉËóª
            for (let alga of algae) {
                if (Math.abs(alga.position.y - headY) > Y_THRESHOLD) continue;
                
                const x = (alga.position.x + WORLD_SIZE/2) * scale;
                const z = mapSize - ((-alga.position.z) + WORLD_SIZE/2) * scale;
                
                if (x >= 0 && x <= mapSize && z >= 0 && z <= mapSize) {
                    miniMapCtx.fillStyle = '#55ff55';
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(x, z, 3, 0, Math.PI * 2);
                    miniMapCtx.fill();
                }
            }
            
            // ÁªòÂà∂Êµ∑Â∏¶
            for (let kelp of kelps) {
                if (Math.abs(kelp.position.y - headY) > Y_THRESHOLD) continue;
                
                const x = (kelp.position.x + WORLD_SIZE/2) * scale;
                const z = mapSize - ((-kelp.position.z) + WORLD_SIZE/2) * scale;
                
                if (x >= 0 && x <= mapSize && z >= 0 && z <= mapSize) {
                    miniMapCtx.fillStyle = '#aa88ff';
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(x, z, 4, 0, Math.PI * 2);
                    miniMapCtx.fill();
                }
            }
            
            // ÁªòÂà∂ÂèòÂΩ¢Ëô´
            for (let amoeba of amoebas) {
                if (Math.abs(amoeba.position.y - headY) > Y_THRESHOLD) continue;
                
                const x = (amoeba.position.x + WORLD_SIZE/2) * scale;
                const z = mapSize - ((-amoeba.position.z) + WORLD_SIZE/2) * scale;
                
                if (x >= 0 && x <= mapSize && z >= 0 && z <= mapSize) {
                    miniMapCtx.fillStyle = '#ff88cc';
                    miniMapCtx.beginPath();
                    miniMapCtx.arc(x, z, 5, 0, Math.PI * 2);
                    miniMapCtx.fill();
                }
            }
            
            // Áé©ÂÆ∂ËõáÂ§¥‰ΩçÁΩÆËΩ¨Êç¢
            const headX = (head.position.x + WORLD_SIZE/2) * scale;
            const headZ = mapSize - ((-head.position.z) + WORLD_SIZE/2) * scale;
            
            // Á°Æ‰øùÁé©ÂÆ∂ËõáÂ§¥Âú®ÂèØËßÅËåÉÂõ¥ÂÜÖ
            if (headX >= 0 && headX <= mapSize && headZ >= 0 && headZ <= mapSize) {
                // ÁªòÂà∂Áé©ÂÆ∂ËõáÂ§¥
                miniMapCtx.fillStyle = '#00ffaa';
                miniMapCtx.beginPath();
                miniMapCtx.arc(headX, headZ, 5, 0, Math.PI * 2);
                miniMapCtx.fill();
                
                // ÁªòÂà∂Áé©ÂÆ∂ËõáË∫´
                for (let i = 1; i < snake.length; i++) {
                    const segment = snake[i];
                    const segX = (segment.position.x + WORLD_SIZE/2) * scale;
                    const segZ = mapSize - ((-segment.position.z) + WORLD_SIZE/2) * scale;
                    
                    if (segX >= 0 && segX <= mapSize && segZ >= 0 && segZ <= mapSize) {
                        miniMapCtx.fillStyle = '#00aaff';
                        miniMapCtx.beginPath();
                        miniMapCtx.arc(segX, segZ, 3, 0, Math.PI * 2);
                        miniMapCtx.fill();
                    }
                }
                
                // ÊñπÂêëÊåáÁ§∫
                const dirX = headX + direction.x * 20;
                const dirZ = headZ + direction.z * 20;
                
                miniMapCtx.strokeStyle = '#00ffaa';
                miniMapCtx.lineWidth = 2;
                miniMapCtx.beginPath();
                miniMapCtx.moveTo(headX, headZ);
                miniMapCtx.lineTo(dirX, dirZ);
                miniMapCtx.stroke();
            }
            
            // Êõ¥Êñ∞È´òÂ∫¶ÊåáÁ§∫Âô®
            document.querySelector('.height-indicator').textContent = `y: ${Math.round(head.position.y)}`;
        }
        
        // ÂàùÂßãÂåñËõáË∫´ÊùêË¥®
        function initSnakeMaterials() {
            snakeBodyMaterials = [];
            
            // ÂàõÂª∫ËõáË∫´ÊùêË¥®ÁöÑÊ∏êÂèò
            const headColor = "#00ffaa";
            const bodyStartColor = "#00ffaa";
            const bodyEndColor = "#00aaff";
            
            for (let i = 0; i < 10; i++) {
                const ratio = i / 9;
                const color = interpolateColor(bodyStartColor, bodyEndColor, ratio);
                
                snakeBodyMaterials.push(new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color(color),
                    shininess: 80,
                    emissive: new THREE.Color(color).multiplyScalar(0.1),
                    emissiveIntensity: 0.5
                }));
            }
        }
        
        // È¢úËâ≤ÊèíÂÄºÂáΩÊï∞
        function interpolateColor(color1, color2, ratio) {
            const r1 = parseInt(color1.substring(1, 3), 16);
            const g1 = parseInt(color1.substring(3, 5), 16);
            const b1 = parseInt(color1.substring(5, 7), 16);
            
            const r2 = parseInt(color2.substring(1, 3), 16);
            const g2 = parseInt(color2.substring(3, 5), 16);
            const b2 = parseInt(color2.substring(5, 7), 16);
            
            const r = Math.round(r1 + (r2 - r1) * ratio);
            const g = Math.round(g1 + (g2 - g1) * ratio);
            const b = Math.round(b1 + (b2 - b1) * ratio);
            
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        
        // ÂàùÂßãÂåñËõá
        function initSnake() {
            // ÁßªÈô§Áé∞ÊúâËõáË∫´
            snake.forEach(segment => scene.remove(segment));
            snake = [];
            positionHistory = [];
            
            // ÂàõÂª∫ËõáÂ§¥
            const headGeometry = new THREE.BoxGeometry(12, 12, 12);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: new THREE.Color("#00ffaa"),
                shininess: 100,
                emissive: new THREE.Color("#00ffaa").multiplyScalar(0.3),
                emissiveIntensity: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0, 0);
            head.castShadow = true;
            head.receiveShadow = true;
            scene.add(head);
            snake.push(head);
            targetPosition.copy(head.position);
            
            // ÂàõÂª∫ÂàùÂßãËõáË∫´
            for (let i = 1; i < snakeLength; i++) {
                addSnakeSegment();
            }
        }
        
        // Ê∑ªÂä†ËõáË∫´ÊÆµ
        function addSnakeSegment() {
            const segmentGeometry = new THREE.BoxGeometry(11, 11, 11);
            const materialIndex = (snake.length - 1) % snakeBodyMaterials.length;
            const segment = new THREE.Mesh(segmentGeometry, snakeBodyMaterials[materialIndex]);
            
            // ‰ΩçÁΩÆÂú®ËõáÂ∞æ‰πãÂêé
            const lastSegment = snake[snake.length - 1];
            segment.position.copy(lastSegment.position);
            segment.position.x -= direction.x * 12;
            segment.position.y -= direction.y * 12;
            segment.position.z -= direction.z * 12;
            
            segment.castShadow = true;
            segment.receiveShadow = true;
            scene.add(segment);
            snake.push(segment);
        }
        
        // ÂàõÂª∫È£üÁâ©
        function createFoods() {
            // ÁßªÈô§ÊóßÈ£üÁâ©
            foods.forEach(food => scene.remove(food));
            foods = [];
            
            const foodGeometry = new THREE.SphereGeometry(8, 16, 16);
            const foodMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff5555,
                shininess: 100,
                emissive: 0xaa0000,
                emissiveIntensity: 0.5
            });
            
            for (let i = 0; i < FOOD_COUNT; i++) {
                const food = new THREE.Mesh(foodGeometry, foodMaterial);
                food.castShadow = true;
                food.receiveShadow = true;
                
                // ÈöèÊú∫‰ΩçÁΩÆ
                food.position.set(
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    -(Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2)
                );
                
                scene.add(food);
                foods.push(food);
            }
        }
        
        // ÂàõÂª∫ÈöúÁ¢çÁâ©
        function createObstacles() {
            // ÁßªÈô§ÊóßÈöúÁ¢çÁâ©
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];
            
            const obstacleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xaa55ff,
                shininess: 60,
                emissive: 0x5511aa,
                emissiveIntensity: 0.3
            });
            
            for (let i = 0; i < OBSTACLE_COUNT; i++) {
                const size = Math.random() * 30 + 20;
                const obstacleGeometry = new THREE.BoxGeometry(size, size, size);
                
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                
                // ÈöèÊú∫‰ΩçÁΩÆ
                obstacle.position.set(
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                    -(Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2)
                );
                
                obstacle.castShadow = true;
                obstacle.receiveShadow = true;
                scene.add(obstacle);
                obstacles.push(obstacle);
            }
        }
        
        // ÂàõÂª∫ËæπÁïåÊåáÁ§∫
        function createBoundaryIndicators() {
            const boundaryMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x203050,
                wireframe: true,
                opacity: 0.1,
                transparent: true
            });
            
            const boundaryGeometry = new THREE.BoxGeometry(WORLD_SIZE, WORLD_SIZE, WORLD_SIZE);
            const boundary = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            scene.add(boundary);
        }
        
        // Êõ¥Êñ∞ÊñπÂêëÂêëÈáè
        function updateDirectionVector() {
            // Âπ≥ÊªëËøáÊ∏°ÂûÇÁõ¥ËßíÂ∫¶
            verticalAngle += (targetVerticalAngle - verticalAngle) * 0.2;
            
            // Ê†πÊçÆÊ∞¥Âπ≥ËßíÂíåÂûÇÁõ¥ËßíËÆ°ÁÆóÊñπÂêëÂêëÈáè
            direction.x = Math.cos(verticalAngle) * Math.sin(horizontalAngle);
            direction.y = Math.sin(verticalAngle);
            direction.z = Math.cos(verticalAngle) * Math.cos(horizontalAngle);
            
            // ÂΩí‰∏ÄÂåñ
            direction.normalize();
            
            // ÁøªËΩ¨zËΩ¥
            direction.z = -direction.z;
            
            // Êõ¥Êñ∞ÂÖâÊü±ÊåáÁ§∫Á∫ø
            updatePathCylinder();
            
            // Êõ¥Êñ∞ÂÖâÊü±ÊåáÁ§∫Âô®
            updateBeamIndicator();
        }
        
        // ÂºÄÂßãÁßªÂä®
        function startMove() {
            if (isMoving) return;
            
            isMoving = true;
            moveStartTime = performance.now();
            moveProgress = 0;
            
            // ËÆæÁΩÆÁõÆÊ†á‰ΩçÁΩÆ
            targetPosition.copy(snake[0].position);
            targetPosition.add(direction.clone().multiplyScalar(MOVE_DISTANCE));
        }
        
        // Êõ¥Êñ∞ÁßªÂä®
        function updateMove(timestamp) {
            if (!isMoving) return;
            
            const elapsed = timestamp - moveStartTime;
            moveProgress = Math.min(elapsed / MOVE_DURATION, 1);
            
            // ËÆ°ÁÆóËõáÂ§¥ÂΩìÂâç‰ΩçÁΩÆ
            const newHeadPosition = new THREE.Vector3().lerpVectors(
                snake[0].position, 
                targetPosition, 
                moveProgress
            );
            
            // ‰øùÂ≠òËõáÂ§¥Âéü‰ΩçÁΩÆ
            const prevHeadPosition = snake[0].position.clone();
            
            // Êõ¥Êñ∞ËõáÂ§¥‰ΩçÁΩÆ
            snake[0].position.copy(newHeadPosition);
            
            // ËÆ∞ÂΩï‰ΩçÁΩÆÂéÜÂè≤
            positionHistory.unshift(snake[0].position.clone());
            if (positionHistory.length > HISTORY_MAX_LENGTH) {
                positionHistory.pop();
            }
            
            // Êõ¥Êñ∞ËõáË∫´‰ΩçÁΩÆ
            for (let i = 1; i < snake.length; i++) {
                const targetIndex = Math.min(positionHistory.length - 1, i * SEGMENT_DISTANCE);
                if (targetIndex < positionHistory.length) {
                    const targetPosition = positionHistory[targetIndex];
                    snake[i].position.lerp(targetPosition, 0.3);
                    
                }
            }
            
            // Âú®ÁßªÂä®ËøáÁ®ã‰∏≠Ê£ÄÊü•È£üÁâ©Á¢∞Êíû
            checkFoodCollision();
            
            // Ê£ÄÊü•‰∏éAIËõáÁöÑÁ¢∞Êíû
            checkAISnakeCollision();
            
            // Ê£ÄÊü•‰∏éÂ∞èÁêÉËóªÁöÑÁ¢∞Êíû
            checkAlgaeCollision();
            
            // Ê£ÄÊü•‰∏éÊµ∑Â∏¶ÁöÑÁ¢∞Êíû
            checkKelpCollision();
            
            // Ê£ÄÊü•‰∏éÂèòÂΩ¢Ëô´ÁöÑÁ¢∞Êíû
            checkAmoebaCollision();
            
            // Ê£ÄÊü•ÁßªÂä®ÊòØÂê¶ÂÆåÊàê
            if (moveProgress >= 1) {
                isMoving = false;
                
                // Ê£ÄÊü•Á¢∞Êíû
                if (checkCollision()) {
                    gameOver();
                } else {
                    // Á´ãÂç≥ÂºÄÂßã‰∏ã‰∏ÄÊ¨°ÁßªÂä®
                    startMove();
                }
            }
        }
        
        // Ê£ÄÊü•È£üÁâ©Á¢∞Êíû
        function checkFoodCollision() {
            const headPos = snake[0].position;
            
            for (let j = foods.length - 1; j >= 0; j--) {
                const food = foods[j];
                const distance = headPos.distanceTo(food.position);
                
                // ‰ΩøÁî®Êõ¥Á≤æÁ°ÆÁöÑÁ¢∞ÊíûÊ£ÄÊµã
                if (distance < 50) {
                    score += 10;
                    
                    // ÊØèÂêÉ‰∏Ä‰∏™È£üÁâ©Â¢ûÂä†2ÊÆµË∫´‰Ωì
                    addSnakeSegment();
                    addSnakeSegment();
                    
                    // Â∞ÜË¢´ÂêÉÁöÑÈ£üÁâ©ÁßªÂä®Âà∞Êñ∞‰ΩçÁΩÆ
                    relocateFood(food);
                    
                    // Êõ¥Êñ∞UI
                    updateUI();
                    
                    // Ë∑≥Âá∫Âæ™ÁéØÔºåÈÅøÂÖçÂêå‰∏ÄÂ∏ßÊ£ÄÊµãÂ§ö‰∏™È£üÁâ©
                    break;
                }
            }
        }
        
        // Ê£ÄÊü•‰∏éÂ∞èÁêÉËóªÁöÑÁ¢∞Êíû
        function checkAlgaeCollision() {
            const headPos = snake[0].position;
            
            for (let i = algae.length - 1; i >= 0; i--) {
                const alga = algae[i];
                const distance = headPos.distanceTo(alga.position);
                
                if (distance < 30) {
                    // Â¢ûÂä†ÂàÜÊï∞
                    score += 50
                    
                    // Ê∑ªÂä†ËõáË∫´ÊÆµ
                    addSnakeSegment();
                    
                    // Â∞ÜË¢´ÂêÉÁöÑÂ∞èÁêÉËóªÂèòÊàêÈ£üÁâ©
                    convertToFood(alga);
                    
                    // ‰ªéÂú∫ÊôØ‰∏≠ÁßªÈô§Â∞èÁêÉËóª
                    scene.remove(alga);
                    algae.splice(i, 1);
                    
                    // Êõ¥Êñ∞UI
                    updateUI();
                    
                    break;
                }
            }
        }
        
        // Ê£ÄÊü•‰∏éÊµ∑Â∏¶ÁöÑÁ¢∞Êíû
        function checkKelpCollision() {
            const headPos = snake[0].position;
            
            for (let i = kelps.length - 1; i >= 0; i--) {
                const kelp = kelps[i];
                const distance = headPos.distanceTo(kelp.position);
                
                if (distance < 50) {
                    // Â¢ûÂä†ÂàÜÊï∞
                    score += 30
                    
                    // Ê∑ªÂä†ËõáË∫´ÊÆµ
                    addSnakeSegment();
                    addSnakeSegment();
                    
                    // Â∞ÜË¢´ÂêÉÁöÑÊµ∑Â∏¶ÂèòÊàêÈ£üÁâ©
                    convertToFood(kelp);
                    
                    // ‰ªéÂú∫ÊôØ‰∏≠ÁßªÈô§Êµ∑Â∏¶
                    scene.remove(kelp);
                    kelps.splice(i, 1);
                    
                    // Êõ¥Êñ∞UI
                    updateUI();
                    
                    break;
                }
            }
        }
        
        // Â∞ÜÁâ©‰ΩìËΩ¨Êç¢‰∏∫È£üÁâ©
        function convertToFood(obj) {
            // ÂàõÂª∫È£üÁâ©
            const foodGeometry = new THREE.SphereGeometry(8, 16, 16);
            const foodMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff5555,
                emissive: 0xaa0000,
                emissiveIntensity: 0.5
            });
            const food = new THREE.Mesh(foodGeometry, foodMaterial);
            
            food.position.copy(obj.position);
            food.castShadow = true;
            food.receiveShadow = true;
            
            scene.add(food);
            foods.push(food);
        }
        
        // Ê£ÄÊü•‰∏éAIËõáÁöÑÁ¢∞Êíû
        function checkAISnakeCollision() {
            const headPos = snake[0].position;
            
            for (let i = aiSnakes.length - 1; i >= 0; i--) {
                const aiSnake = aiSnakes[i];
                if (aiSnake.body.length === 0) continue;
                
                const aiHead = aiSnake.body[0];
                const distance = headPos.distanceTo(aiHead.position);
                
                if (distance < 20) {
                    // Áé©ÂÆ∂ËõáÊíûÂà∞AIËõáÂ§¥ÔºåAIËõáÂèòÊàêÈ£üÁâ©
                    convertAISnakeToFood(aiSnake);
                    
                    // ‰ªéÂú∫ÊôØ‰∏≠ÁßªÈô§AIËõá
                    for (let segment of aiSnake.body) {
                        scene.remove(segment);
                    }
                    
                    // ‰ªéAIËõáÊï∞ÁªÑ‰∏≠ÁßªÈô§
                    aiSnakes.splice(i, 1);
                    
                    // Â¢ûÂä†ÂàÜÊï∞
                    score += 500;
                    updateUI();
                    
                    break;
                }
            }
        }
        
        // Â∞ÜAIËõáËΩ¨Êç¢‰∏∫È£üÁâ©
        function convertAISnakeToFood(aiSnake) {
            for (let i = 0; i < aiSnake.body.length; i++) {
                const segment = aiSnake.body[i];
                
                // ÂàõÂª∫È£üÁâ©
                const foodGeometry = new THREE.SphereGeometry(8, 16, 16);
                const foodMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff5555,
                    emissive: 0xaa0000,
                    emissiveIntensity: 0.5
                });
                const food = new THREE.Mesh(foodGeometry, foodMaterial);
                
                food.position.copy(segment.position);
                food.castShadow = true;
                food.receiveShadow = true;
                
                scene.add(food);
                foods.push(food);
            }
        }
        
        // ÈáçÊñ∞ÂÆö‰ΩçÈ£üÁâ©Âà∞Êñ∞‰ΩçÁΩÆ
        function relocateFood(food) {
            food.position.set(
                Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2,
                -(Math.floor(Math.random() * WORLD_SIZE) - WORLD_SIZE/2)
            );
        }
        
        // Ê£ÄÊü•Á¢∞Êíû
        function checkCollision() {
            const head = snake[0].position;
            
            // ËæπÁïåÁ¢∞Êíû
            if (Math.abs(head.x) > WORLD_SIZE/2 - 10 || 
                Math.abs(head.y) > WORLD_SIZE/2 - 10 || 
                Math.abs(head.z) > WORLD_SIZE/2 - 10) {
                return true;
            }
            
            // ÈöúÁ¢çÁâ©Á¢∞Êíû
            for (let obstacle of obstacles) {
                // ‰ΩøÁî®Êõ¥Â§ßÁöÑÊ£ÄÊµãÈòàÂÄº
                if (head.distanceTo(obstacle.position) < 1) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Ê∏∏ÊàèÁªìÊùü
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'flex';
        }
        
        // ÈáçÁΩÆÊ∏∏Êàè
        function resetGame() {
            // ÈáçÁΩÆÊ∏∏ÊàèÁä∂ÊÄÅ
            score = 0;
            snakeLength = 3;
            gameRunning = true;
            isMoving = true;
            horizontalAngle = Math.PI / 3;
            verticalAngle = 0;
            targetVerticalAngle = 0;
            joystickPower = 0.5;
            positionHistory = [];
            powerLocked = false;
            firstPersonMode = false;
            
            // ÈáçÁΩÆÂä†ÈÄüÂ∫¶
            for (let key in keyAcceleration) {
                keyAcceleration[key].acceleration = 0;
                keyAcceleration[key].pressed = false;
            }
            
            // ÈáçÁΩÆUIÁä∂ÊÄÅ
            document.getElementById('powerLockBtn').classList.remove('locked');
            document.getElementById('powerLockBtn').textContent = 'üîì';
            document.getElementById('viewToggleBtn').textContent = "üëÅÔ∏èV";
            document.getElementById('viewToggleBtn').style.backgroundColor = "rgba(10, 25, 50, 0.8)";
            document.getElementById('fpIndicator').style.display = 'none';
            document.getElementById('beamDirection').style.display = 'none';
            document.getElementById('accelerationIndicator').style.display = 'none';
            document.getElementById('amoebaIndicator').style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('touchControls').style.display = 'none';
            
            // ÈáçÁΩÆÁõ∏Êú∫
            camera.position.set(500, 400, 500);
            camera.lookAt(0, 0, 0);
            controls.reset();
            controls.enabled = true;
            
            // Êõ¥Êñ∞ÊñπÂêëÂêëÈáè
            updateDirectionVector();
            
            // ÈáçÊñ∞ÂàùÂßãÂåñËõáÂíåÈ£üÁâ©
            initSnake();
            createFoods();
            createObstacles();
            
            // ÁßªÈô§ÊâÄÊúâAIËõá
            for (let aiSnake of aiSnakes) {
                for (let segment of aiSnake.body) {
                    scene.remove(segment);
                }
            }
            aiSnakes = [];
            
            // ÁßªÈô§ÊâÄÊúâÂ∞èÁêÉËóª
            for (let alga of algae) {
                scene.remove(alga);
            }
            algae = [];
            
            // ÁßªÈô§ÊâÄÊúâÊµ∑Â∏¶
            for (let kelp of kelps) {
                scene.remove(kelp);
            }
            kelps = [];
            
            // ÁßªÈô§ÊâÄÊúâÂèòÂΩ¢Ëô´
            for (let amoeba of amoebas) {
                scene.remove(amoeba);
            }
            amoebas = [];
            
            // ÈáçÊñ∞ÂàõÂª∫AIËõá
            createAISnakes();
            
            // ÈáçÊñ∞ÂàõÂª∫Â∞èÁêÉËóªÂíåÊµ∑Â∏¶
            createAlgae();
            createKelps();
            
            // ÈáçÊñ∞ÂàõÂª∫ÂèòÂΩ¢Ëô´
            createAmoebas();
            
            // Êõ¥Êñ∞UI
            updateUI();
            
            // Êõ¥Êñ∞ÂäüÁéáÊéßÂà∂
            updatePowerControl();
            
            // Êõ¥Êñ∞ÊëáÊùÜÊòæÁ§∫
            updateJoystickDisplay();
            
            // ÈöêËóèÊ∏∏ÊàèÁªìÊùüÁîªÈù¢
            document.getElementById('gameOver').style.display = 'none';
            
            // ÈáçÁΩÆÊ∏∏ÊàèÊó∂Èó¥
            gameStartTime = Date.now();
            
            // ÂºÄÂßãÁ¨¨‰∏ÄÊ¨°ÁßªÂä®
            startMove();
        }
        
        // Êõ¥Êñ∞UI
        function updateUI() {
            document.getElementById('scoreDisplay').textContent = `üß¨: ${score}`;
        }
        
        // ÈîÆÁõò‰∫ã‰ª∂Â§ÑÁêÜ
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            keys[key] = true;
            
            // Êõ¥Êñ∞Âä†ÈÄüÂ∫¶Áä∂ÊÄÅ
            if (['a', 'd', 'w', 's'].includes(key) && !keyAcceleration[key].pressed) {
                keyAcceleration[key].pressed = true;
                keyAcceleration[key].startTime = performance.now();
            }
            
            switch (event.key) {
                case ' ':
                    gameRunning = !gameRunning;
                    document.getElementById('pauseOverlay').style.display = gameRunning ? 'none' : 'flex';
                    break;
                case 'r':
                case 'R':
                    resetGame();
                    break;
                case 'v':
                case 'V':
                    toggleFirstPerson();
                    break;
            }
        }
        
        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            keys[key] = false;
            
            // ÈáçÁΩÆÂä†ÈÄüÂ∫¶Áä∂ÊÄÅ
            if (['a', 'd', 'w', 's'].includes(key)) {
                keyAcceleration[key].pressed = false;
                keyAcceleration[key].acceleration = 0;
                document.getElementById('accelerationIndicator').style.display = 'none';
            }
        }
        
        // Â§ÑÁêÜÈîÆÁõòËæìÂÖ•ÔºàÂ∏¶Âä†ÈÄüÂ∫¶Ôºâ
        function handleKeyboardInput() {
            let anyKeyPressed = false;
            let maxAcceleration = 0;
            
            // Êõ¥Êñ∞Âä†ÈÄüÂ∫¶
            for (let key in keyAcceleration) {
                if (keyAcceleration[key].pressed) {
                    // Â¢ûÂä†Âä†ÈÄüÂ∫¶Ôºà‰ΩÜ‰∏çË∂ÖËøáÊúÄÂ§ßÂÄºÔºâ
                    keyAcceleration[key].acceleration = Math.min(
                        MAX_ACCELERATION, 
                        keyAcceleration[key].acceleration + ACCELERATION_RATE
                    );
                    
                    anyKeyPressed = true;
                    maxAcceleration = Math.max(maxAcceleration, keyAcceleration[key].acceleration);
                } else if (keyAcceleration[key].acceleration > 0) {
                    // Ë°∞ÂáèÂä†ÈÄüÂ∫¶
                    keyAcceleration[key].acceleration = Math.max(
                        0, 
                        keyAcceleration[key].acceleration - ACCELERATION_DECAY
                    );
                }
            }
            
            // ÊòæÁ§∫Âä†ÈÄüÂ∫¶ÊåáÁ§∫Âô®
            if (anyKeyPressed) {
                const indicator = document.getElementById('accelerationIndicator');
                indicator.style.display = 'block';
                indicator.textContent = `üìà: ${maxAcceleration.toFixed(1)}x`;
            }
            
            // ËÆ°ÁÆóÂÆûÈôÖÈÄüÂ∫¶ÔºöÂü∫Á°ÄÈÄüÂ∫¶ * (1 + Âä†ÈÄüÂ∫¶)
            const currentSpeedA = BASE_KEY_SPEED * (1 + keyAcceleration.a.acceleration);
            const currentSpeedD = BASE_KEY_SPEED * (1 + keyAcceleration.d.acceleration);
            const currentSpeedW = BASE_POWER_SPEED * (1 + keyAcceleration.w.acceleration);
            const currentSpeedS = BASE_POWER_SPEED * (1 + keyAcceleration.s.acceleration);

            if (keys['a']) {
                horizontalAngle -= currentSpeedA;
            }
            if (keys['d']) {
                horizontalAngle += currentSpeedD;
            }
            if (keys['w'] && !powerLocked) {
                joystickPower = Math.min(1, joystickPower + 0.0012*currentSpeedW);
            }
            if (keys['s'] && !powerLocked) {
                joystickPower = Math.max(0, joystickPower - 0.0012*currentSpeedS);
            }
            
            // Êõ¥Êñ∞ÊëáÊùÜËßíÂ∫¶
            joystickAngle = horizontalAngle - Math.PI/2;
            
            // Êõ¥Êñ∞ÂûÇÁõ¥ËßíÂ∫¶
            verticalAngle = Math.max(-Math.PI/2, Math.min(Math.PI/2, (joystickPower - 0.5) * Math.PI/2));
            
            // Êõ¥Êñ∞ÊñπÂêëÂêëÈáè
            updateDirectionVector();
            
            // Êõ¥Êñ∞ÂäüÁéáÊéßÂà∂
            updatePowerControl();
            
            // Êõ¥Êñ∞ÊëáÊùÜÊòæÁ§∫
            updateJoystickDisplay();
        }
        
        // Á™óÂè£Â§ßÂ∞èË∞ÉÊï¥
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            // ËÆæÁΩÆËÆæÂ§áÂÉèÁ¥†ÊØî
            const pixelRatio = Math.min(window.devicePixelRatio, 2);
            renderer.setPixelRatio(pixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // ÈáçÊñ∞ÂàùÂßãÂåñÂ∞èÂú∞Âõæ‰ª•ÈÄÇÂ∫îÊñ∞Â∞∫ÂØ∏
            initMiniMap();
        }
        
        // Êõ¥Êñ∞AIËõá
        function updateAISnakes() {
            for (let aiSnake of aiSnakes) {
                if (aiSnake.body.length === 0) continue;
                
                // ÈöèÊú∫ÊîπÂèòÊñπÂêë
                aiSnake.turnCounter++;
                if (aiSnake.turnCounter > aiSnake.turnInterval) {
                    aiSnake.direction = new THREE.Vector3(
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1,
                        Math.random() * 2 - 1
                    ).normalize();
                    aiSnake.turnCounter = 0;
                    aiSnake.turnInterval = Math.floor(Math.random() * 100) + 50;
                }
                
                // ÁßªÂä®AIËõáÂ§¥
                const head = aiSnake.body[0];
                head.position.add(aiSnake.direction.clone().multiplyScalar(aiSnake.speed));
                
                // ËæπÁïåÊ£ÄÊü•
                if (Math.abs(head.position.x) > WORLD_SIZE/2 - 10) {
                    aiSnake.direction.x *= -1;
                    head.position.x = Math.sign(head.position.x) * (WORLD_SIZE/2 - 10);
                }
                if (Math.abs(head.position.y) > WORLD_SIZE/2 - 10) {
                    aiSnake.direction.y *= -1;
                    head.position.y = Math.sign(head.position.y) * (WORLD_SIZE/2 - 10);
                }
                if (Math.abs(head.position.z) > WORLD_SIZE/2 - 10) {
                    aiSnake.direction.z *= -1;
                    head.position.z = Math.sign(head.position.z) * (WORLD_SIZE/2 - 10);
                }
                
                // ËÆ∞ÂΩï‰ΩçÁΩÆÂéÜÂè≤
                aiSnake.positionHistory.unshift(head.position.clone());
                if (aiSnake.positionHistory.length > HISTORY_MAX_LENGTH) {
                    aiSnake.positionHistory.pop();
                }
                
                // Êõ¥Êñ∞AIËõáË∫´
                for (let i = 1; i < aiSnake.body.length; i++) {
                    const targetIndex = Math.min(aiSnake.positionHistory.length - 1, i * SEGMENT_DISTANCE);
                    if (targetIndex < aiSnake.positionHistory.length) {
                        const targetPosition = aiSnake.positionHistory[targetIndex];
                        aiSnake.body[i].position.lerp(targetPosition, 0.3);
                    }
                }
            }
        }
        
        // Êõ¥Êñ∞Â∞èÁêÉËóª
        function updateAlgae() {
            for (let i = 0; i < algae.length; i++) {
                const alga = algae[i];
                
                // Êõ¥Êñ∞‰ΩçÁΩÆ
                alga.position.add(alga.userData.direction);
                
                // ÊóãËΩ¨
                alga.rotation.x += alga.userData.rotationSpeed.x;
                alga.rotation.y += alga.userData.rotationSpeed.y;
                alga.rotation.z += alga.userData.rotationSpeed.z;
                
                // ËæπÁïåÊ£ÄÊü• - ÂèçÂºπ
                if (Math.abs(alga.position.x) > WORLD_SIZE/2 - 20) {
                    alga.userData.direction.x *= -1;
                    alga.position.x = Math.sign(alga.position.x) * (WORLD_SIZE/2 - 20);
                }
                if (Math.abs(alga.position.y) > WORLD_SIZE/2 - 20) {
                    alga.userData.direction.y *= -1;
                    alga.position.y = Math.sign(alga.position.y) * (WORLD_SIZE/2 - 20);
                }
                if (Math.abs(alga.position.z) > WORLD_SIZE/2 - 20) {
                    alga.userData.direction.z *= -1;
                    alga.position.z = Math.sign(alga.position.z) * (WORLD_SIZE/2 - 20);
                }
            }
        }
        
        // Êõ¥Êñ∞Êµ∑Â∏¶
        function updateKelps() {
            const time = Date.now() * 0.001;
            
            for (let i = 0; i < kelps.length; i++) {
                const kelp = kelps[i];
                const t = time + kelp.userData.timeOffset * 0.001;
                
                // Êï¥‰ΩìÊëÜÂä®ÊïàÊûú
                kelp.rotation.y = kelp.userData.baseRotation + 
                                 Math.sin(t * kelp.userData.swingSpeed) * kelp.userData.swingAmplitude;
                
                // Âè∂ÁâáÊ≥¢Êµ™ÊïàÊûú
                const leaves = [];
                kelp.traverse(child => {
                    if (child.isMesh && child.geometry.type === "PlaneGeometry") {
                        leaves.push(child);
                    }
                });
                
                for (let j = 0; j < leaves.length; j++) {
                    const leaf = leaves[j];
                    const waveOffset = kelp.userData.leafWaveOffset + j * 0.3;
                    
                    // Ê≥¢Êµ™ÊïàÊûú - ‰∏ä‰∏ãÁßªÂä®
                    const waveY = Math.sin(t * 1.5 + waveOffset) * 3;
                    
                    // Ê≥¢Êµ™ÊïàÊûú - Â∑¶Âè≥ÊëÜÂä®
                    const waveX = Math.sin(t * 1.8 + waveOffset) * 2;
                    
                    // Â∫îÁî®Ê≥¢Êµ™ÊïàÊûú
                    leaf.position.y = leaf.userData.originalY + waveY;
                    leaf.position.x = leaf.userData.originalX + waveX;
                    
                    // ËΩªÂæÆÊóãËΩ¨ÂèòÂåñ
                    leaf.rotation.z = leaf.userData.originalRotationZ + 
                                     Math.sin(t * 2 + waveOffset) * 0.1;
                }
                
                // Êõ¥Êñ∞Ê∞îÊ≥°ÊïàÊûú
                const bubbleGroup = kelp.children.find(child => child.isGroup);
                if (bubbleGroup) {
                    bubbleGroup.children.forEach(bubble => {
                        // Ê∞îÊ≥°‰∏ä‰∏ãÊµÆÂä®
                        bubble.position.y = bubble.userData.startHeight + 
                                          Math.sin(t * bubble.userData.speed + bubble.userData.offset) * 
                                          bubble.userData.amplitude * 10;
                        
                        // Ê∞îÊ≥°ÊóãËΩ¨
                        bubble.rotation.x += 0.01;
                        bubble.rotation.y += 0.015;
                    });
                }
            }
        }
        
        // Âê∏ÂºïÈôÑËøëÈ£üÁâ©
        function attractNearbyFoods() {
            if (snake.length === 0) return;
            
            const headPos = snake[0].position;
            
            for (let i = 0; i < foods.length; i++) {
                const food = foods[i];
                const distance = headPos.distanceTo(food.position);
                
                // Â¶ÇÊûúÈ£üÁâ©Âú®Âê∏ÂºïËåÉÂõ¥ÂÜÖÔºåÂàôÂêëËõáÂ§¥ÁßªÂä®
                if (distance < ATTRACTION_DISTANCE) {
                    // ËÆ°ÁÆó‰ªéÈ£üÁâ©ÊåáÂêëËõáÂ§¥ÁöÑÊñπÂêëÂêëÈáè
                    const direction = new THREE.Vector3().subVectors(headPos, food.position).normalize();
                    
                    // Ê†πÊçÆË∑ùÁ¶ªË∞ÉÊï¥ÁßªÂä®ÈÄüÂ∫¶
                    const speed = ATTRACTION_SPEED * (distance / ATTRACTION_DISTANCE);
                    
                    // ÁßªÂä®È£üÁâ©
                    food.position.add(direction.multiplyScalar(speed));
                }
            }
        }
        
        // Âä®ÁîªÂæ™ÁéØ
        function animate(timestamp) {
            requestAnimationFrame(animate);
            
            frameCount++;
            if (timestamp - lastFpsUpdate >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = timestamp;
            }
            
            // Â§ÑÁêÜÈîÆÁõòËæìÂÖ•
            handleKeyboardInput();
            
            // Êõ¥Êñ∞Ê∏∏ÊàèÁä∂ÊÄÅ
            if (gameRunning) {
                // Êõ¥Êñ∞ÊñπÂêëÂêëÈáè
                updateDirectionVector();
                
                // Êõ¥Êñ∞ÁßªÂä®
                if (isMoving) {
                    updateMove(timestamp);
                }
                
                // Êõ¥Êñ∞AIËõá
                if (frameCount % 2 === 0) {
                    updateAISnakes();
                }
                
                // Êõ¥Êñ∞Â∞èÁêÉËóª
                updateAlgae();
                
                // Êõ¥Êñ∞Êµ∑Â∏¶
                updateKelps();
                
                // Êõ¥Êñ∞ÂèòÂΩ¢Ëô´
                updateAmoebas(timestamp);
                
                // ‰ΩøÈ£üÁâ©ÊóãËΩ¨
                for (let food of foods) {
                    food.rotation.x += 0.008;
                    food.rotation.y += 0.012;
                }
                
                // Âê∏ÂºïÈôÑËøëÈ£üÁâ©
                attractNearbyFoods();
                
                // ËõáÂ§¥ÂëºÂê∏ÊïàÊûú
                if (snake.length > 0) {
                    const head = snake[0];
                    const scale = 1 + Math.sin(timestamp * 0.003) * 0.1;
                    head.scale.set(scale, scale, scale);
                }
                
                // Êõ¥Êñ∞ÂÖâÊü±
                updatePathCylinder();
                
                // Êõ¥Êñ∞Â∞èÂú∞Âõæ
                updateMiniMap();
                
                // Êõ¥Êñ∞Á¨¨‰∏Ä‰∫∫Áß∞ËßÜËßí
                if (firstPersonMode) {
                    updateFirstPersonCamera();
                }
            }
            
            // Êõ¥Êñ∞Êéß‰ª∂
            if (controls.enabled) {
                controls.update();
            }
            
            // Ê∏≤ÊüìÂú∫ÊôØ
            renderer.render(scene, camera);
        }
        
        // ËÆæÁΩÆÊëáÊùÜÂÆπÂô®ÊãñÂä®ÂäüËÉΩ
        function setupJoystickDrag() {
            const joystickContainer = document.getElementById('joystickContainer');
            let isDragging = false;
            let startX, startY;
            let startLeft, startBottom;

            // Èº†Ê†á‰∫ã‰ª∂
            joystickContainer.addEventListener('mousedown', function(e) {
                // ‰ªÖÂΩìÁÇπÂáªÂú®ÂÆπÂô®‰∏ä‰ΩÜ‰∏çÊòØÊëáÊùÜÂ§¥Êó∂ÊâçÊãñÂä®
                if (e.target !== joystickContainer && !e.target.classList.contains('drag-handle')) {
                    return;
                }
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                // Ëé∑ÂèñÂΩìÂâç‰ΩçÁΩÆ
                startLeft = parseFloat(joystickContainer.style.left) || 60;
                startBottom = parseFloat(joystickContainer.style.bottom) || 60;
                
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaX = e.clientX - startX;
                const deltaY = startY - e.clientY;
                
                // ËÆ°ÁÆóÊñ∞‰ΩçÁΩÆ
                let newLeft = startLeft + deltaX;
                let newBottom = startBottom - deltaY;
                
                // ËæπÁïåÊ£ÄÊü•
                newLeft = Math.max(10, Math.min(window.innerWidth - joystickContainer.offsetWidth - 10, newLeft));
                newBottom = Math.max(10, Math.min(window.innerHeight - joystickContainer.offsetHeight - 10, newBottom));
                
                // Â∫îÁî®Êñ∞‰ΩçÁΩÆ
                joystickContainer.style.left = newLeft + 'px';
                joystickContainer.style.bottom = newBottom + 'px';
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
            });

            // Ëß¶Êë∏‰∫ã‰ª∂
            joystickContainer.addEventListener('touchstart', function(e) {
                // ‰ªÖÂΩìÁÇπÂáªÂú®ÂÆπÂô®‰∏ä‰ΩÜ‰∏çÊòØÊëáÊùÜÂ§¥Êó∂ÊâçÊãñÂä®
                if (e.target !== joystickContainer && !e.target.classList.contains('drag-handle')) {
                    return;
                }
                
                if (e.touches.length === 1) {
                    isDragging = true;
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                    
                    startLeft = parseFloat(joystickContainer.style.left) || 60;
                    startBottom = parseFloat(joystickContainer.style.bottom) || 60;
                    
                    e.preventDefault();
                }
            }, { passive: false });

            document.addEventListener('touchmove', function(e) {
                if (!isDragging || e.touches.length !== 1) return;
                
                const touch = e.touches[0];
                const deltaX = touch.clientX - startX;
                const deltaY = touch.clientY - startY;
                
                let newLeft = startLeft + deltaX;
                let newBottom = startBottom - deltaY;
                
                // ËæπÁïåÊ£ÄÊü•
                newLeft = Math.max(10, Math.min(window.innerWidth - joystickContainer.offsetWidth - 10, newLeft));
                newBottom = Math.max(10, Math.min(window.innerHeight - joystickContainer.offsetHeight - 10, newBottom));
                
                joystickContainer.style.left = newLeft + 'px';
                joystickContainer.style.bottom = newBottom + 'px';
                
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchend', function() {
                isDragging = false;
            });
        }
        
        // ÂàùÂßãÂåñÊ∏∏Êàè
        window.onload = function() {
            init();
            updateDirectionVector();
            updateGearColor();
            updateJoystickDisplay();
        };
    </script>
</body>
</html>